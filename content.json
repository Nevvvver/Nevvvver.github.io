{"meta":{"title":"Never","subtitle":"","description":"","author":"Never","url":"https://Nevvvver.github.io","root":"/"},"pages":[{"title":"分类","date":"2022-03-14T19:37:47.600Z","updated":"2022-03-14T19:37:47.600Z","comments":false,"path":"categories/index.html","permalink":"https://nevvvver.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-03-14T19:30:14.438Z","updated":"2022-03-14T19:30:14.438Z","comments":false,"path":"tags/index.html","permalink":"https://nevvvver.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"《JavaScript权威指南(第6版)》笔记","slug":"JavaScript权威指南","date":"2022-07-11T09:27:54.000Z","updated":"2022-07-18T09:48:41.697Z","comments":true,"path":"2022/07/11/JavaScript权威指南/","link":"","permalink":"https://nevvvver.github.io/2022/07/11/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/","excerpt":"","text":"第〇部分第1章 JavaScript概述电子书：《JavaScript权威指南(第6版)》 第一部分 JavaScript 语言核心第2章 词法结构2.1 字符集第6章 对象 内置对象（native object）是由ECMAScript规范定义的对象或类。例如数组、函数、日期、正则表达式等。 宿主对象（host object）是由JavaScript解释器所嵌入的宿主环境（比如Web浏览器）定义的。 自定义对象 （user-defiend object）是由运行中的JavaScript代码创建的对象。 自有属性（own property）是直接在对象中定义的属性。 继承属性（inherited property）是在对象的原型对象中定义的属性。 6.1 创建对象对象直接量 1234567891011var empty = &#123;&#125;;var point = &#123; x:0, y:0 &#125;;var book = &#123; &quot;main title&quot;: &quot;JavaScript&quot;, &quot;sub-title&quot;: &quot;The Definitive Guide&quot;, &quot;for&quot;: &quot;all audiences&quot;, author: &#123; firstname: &quot;David&quot;, surname: &quot;Flanagan&quot; &#125;&#125; 对象直接量是一个表达式，表达式的每次运算都创建并初始化一个新的对象。 关键字new 1234var o = new Object(); // 创建一个空对象，和&#123;&#125;一样var a = new Array(); // 创建一个空数组，和[]一样var d = new Date(); // 创建一个白哦是当前时间的Date对象var r = new RegExp(&quot;js&quot;); // 创建一个可以进行模式匹配的RegExp对象 new运算符后面跟的是一个函数调用，这个函数被称为构造函数（constructor）。js中原始类型都包含内置的构造函数，也可以自己定义构造函数。 原型 每一个JavaScript对象（null除外）对合另一个对象（原型）相关联，每一个对象都从原型继承属性。 通过new Object()创建的对象也继承自Object.prototype，new Array() Object.create()（ES5） 第9章 类和模块9.1 类和原型 类的所有实例对象都从同一个原型对象上继承属性。 12345// range.js: 实现一个能表示值的范围的类// 这个工厂方法返回一个新的“范围对象”function range(from, to) &#123;&#125; 9.2 类和构造函数1234var F = function()&#123;&#125;; // 这是一个函数对象var p = F.prototype; // 这是F相关联的原型对象var c = p.constructor; // 这是与原型相关联的函数c === F // =&gt; true 12var o = new F(); // 创建类F的一个实例o.constructor === F // =&gt; true construtor属性指代这个类 对于任意函数 F.prototype.constructor === F 9.3 JavaScript中Java式的类继承 类字段、类方法；实例字段、实例方法 构造函数对象原型对象 9.5 类和类型 三种可以检测对象的类的方法：instanceof运算符、constructor属性、构造函数的名字。 三种方法都不完美，但利用鸭式辩型，可以更加关注对象可以完成什么工做而不是对象属于哪个类。 instanceof运算符 o instanceof c 返回true，表示o继承自c.prototype，这里的继承可以不是直接继承 构造函数是类的公共标识，但原型是唯一的标识。instanceof检测了对象的继承关系，而不是检测创建对象的构造函数 constructor属性-","categories":[{"name":"Books","slug":"Books","permalink":"https://nevvvver.github.io/categories/Books/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://nevvvver.github.io/tags/javascript/"}]},{"title":"jsoneditor-react的类型声明文件","slug":"jsoneditor-react的类型声明文件","date":"2022-06-07T09:25:44.000Z","updated":"2022-06-07T09:46:02.848Z","comments":true,"path":"2022/06/07/jsoneditor-react的类型声明文件/","link":"","permalink":"https://nevvvver.github.io/2022/06/07/jsoneditor-react%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6/","excerpt":"","text":"jsoneditor-react.d.ts放在src下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475declare module &#x27;jsoneditor-react&#x27; &#123; export class JsonEditor extends React.Component&lt;JsonEditorProps&gt; &#123; public jsonEditor: unknown; &#125; type Mode = &#x27;tree&#x27; | &#x27;view&#x27; | &#x27;form&#x27; | &#x27;code&#x27; | &#x27;text&#x27;; interface JsonEditorProps &#123; value: unknown; /** Set the editor mode. Default &#x27;tree&#x27; */ mode?: Mode; /** Initial field name for root node */ name?: string; /** Validate the JSON object against a JSON schema. */ schema: unknown; /** Schemas that are referenced using the $ref property */ schemaRefs?: object; /** * If true, object keys in &#x27;tree&#x27;, &#x27;view&#x27; or &#x27;form&#x27; mode list be listed alphabetically * instead by their insertion order. * */ sortObjectKeys?: boolean; /** Set a callback function triggered when json in the JSONEditor change */ onChange?: (value: object[]) =&gt; void; /** * Set a callback function triggered when an error occurs. * Invoked with the error as first argument. * The callback is only invoked for errors triggered by a users action, * like switching from code mode to tree mode or clicking * the Format button whilst the editor doesn&#x27;t contain valid JSON. */ onError?: (error: unknown) =&gt; void; /** Set a callback function triggered right after the mode is changed by the user. */ onModeChange?: (mode: Mode) =&gt; void; onClassName?: (args: &#123; path: unknown; field: unknown; value: unknown &#125;) =&gt; void; /** Provide a version of the Ace editor. Only applicable when mode is code */ ace?: object; /** Provide a instance of ajv,the library used for JSON schema validation. */ ajv?: object; /** Set the Ace editor theme, uses included &#x27;ace/theme/jsoneditor&#x27; by default. */ theme?: string; /** * Enables history, adds a button Undo and Redo to the menu of the JSONEditor. * Only applicable when mode is &#x27;tree&#x27; or &#x27;form&#x27;. Default to false */ history?: boolean; /** * Adds navigation bar to the menu * the navigation bar visualize the current position on the * tree structure as well as allows breadcrumbs navigation. Default to true */ navigationBar?: boolean; /** * Adds status bar to the buttom of the editor * the status bar shows the cursor position and a count of the selected characters. * Only applicable when mode is &#x27;code&#x27; or &#x27;text&#x27;. Default to true */ statusBar?: boolean; /** Enables a search box in the upper right corner of the JSONEditor. Default to true */ search?: boolean; /** Create a box in the editor menu where the user can switch between the specified modes. */ allowedModes?: Mode[]; /** Html element, or react element to render */ tag?: string | HTMLElement; /** html element custom props */ htmlElementProps?: object; /** callback to get html element reference */ innerRef?: (ref: unknown) =&gt; void; &#125;&#125;","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://nevvvver.github.io/categories/TypeScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://nevvvver.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://nevvvver.github.io/tags/es6/"}]},{"title":"可枚举性(enumerable)","slug":"enumerable","date":"2022-03-14T18:53:58.000Z","updated":"2022-03-15T16:09:02.657Z","comments":true,"path":"2022/03/15/enumerable/","link":"","permalink":"https://nevvvver.github.io/2022/03/15/enumerable/","excerpt":"","text":"描述 在 JavaScript 中，对象的属性可以分为实例属性和原型 (prototype) 属性。 实例属性：指的是自身属性。 原型属性：指的是从原型链上继承的属性。 Object.prototype.hasOwnProperty() 可以判断某一个属性是否是对象的自身属性。 对象的每一个属性都有一个描述对象 (Descriptor) ,描述对象的 enumerable 属性称为“可枚举性”。 引入“可枚举性”这个概念的最初目的，就是让某些属性可以规避掉 for...in 操作。 可枚举性的作用与可枚举性有关的操作： 函数方法 描述 实例属性 原型属性 for...in 遍历对象自身和原型上的所有可枚举属性 〇 〇 Object.keys() 返回对象自身的所有可枚举属性的键名 〇 JSON.stringify 只串行化对象自身的所有可枚举属性 〇 Object.assign()(ES6) 只拷贝对象自身的所有可枚举属性 〇 Object.getOwnPropertyNames() 返回对象自身的所有属性的键名 〇 code samples123456789101112131415function Person() &#123; this.name = &quot;Never&quot;;&#125;;// 通过直接的赋值和属性初始化的属性，可枚举性默认为truePerson.prototype.School = &#x27;Tust&#x27;;let person = new Person();// 通过 Object.defineProperty() 等定义的属性，可枚举性默认为falseObject.defineProperty(person, &quot;sex&quot;, &#123; value: &quot;male&quot;, // enumerable: false&#125;); 12345678910111213Object.keys(person).forEach(function(key) &#123; console.log(key) // name&#125;);for(var p in person)&#123; console.log(p); // name, School&#125;Object.getOwnPropertyNames(person).forEach(function(key) &#123; console.log(key)// name, sex&#125;); 如何判断属性是否可枚举 Object.propertyIsEnumerable() 方法可以判断一个属性是否是对象的可枚举的自身属性。（注：如果判断的属性是原型属性，不管它是否可枚举都会返回false） 123person.propertyIsEnumerable(&#x27;name&#x27;); // trueperson.propertyIsEnumerable(&#x27;School&#x27;); // falseperson.propertyIsEnumerable(&#x27;sex&#x27;); // false","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nevvvver.github.io/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://nevvvver.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://nevvvver.github.io/tags/es6/"}]}],"categories":[{"name":"Books","slug":"Books","permalink":"https://nevvvver.github.io/categories/Books/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://nevvvver.github.io/categories/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://nevvvver.github.io/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://nevvvver.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://nevvvver.github.io/tags/es6/"}]}