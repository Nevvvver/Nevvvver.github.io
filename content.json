{"meta":{"title":"Never","subtitle":"","description":"","author":"Never","url":"http://Nevvvver.github.io","root":"/"},"pages":[{"title":"标签","date":"2022-03-14T19:30:14.438Z","updated":"2022-03-14T19:30:14.438Z","comments":false,"path":"tags/index.html","permalink":"http://nevvvver.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-03-14T19:37:47.600Z","updated":"2022-03-14T19:37:47.600Z","comments":false,"path":"categories/index.html","permalink":"http://nevvvver.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"hexo中接入chatwoot实时聊天","slug":"hexo中接入chatwoot实时聊天","date":"2022-07-18T07:58:35.000Z","updated":"2022-07-18T09:43:10.716Z","comments":true,"path":"2022/07/18/hexo中接入chatwoot实时聊天/","link":"","permalink":"http://nevvvver.github.io/2022/07/18/hexo%E4%B8%AD%E6%8E%A5%E5%85%A5chatwoot%E5%AE%9E%E6%97%B6%E8%81%8A%E5%A4%A9/","excerpt":"","text":"一键部署chatwoothttps://dashboard.heroku.com/new?template=https%3A%2F%2Fgithub.com%2Fchatwoot%2Fchatwoot%2Ftree%2Fmasterhttps://www.chatwoot.com/docs/self-hosted/deployment/heroku","categories":[],"tags":[]},{"title":"《深入浅出Node.js》笔记","slug":"深入浅出NodeJS","date":"2022-07-13T09:35:49.000Z","updated":"2022-07-15T11:33:02.043Z","comments":true,"path":"2022/07/13/深入浅出NodeJS/","link":"","permalink":"http://nevvvver.github.io/2022/07/13/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS/","excerpt":"","text":"第1章 Node简介电子书：《深入浅出Node.js》 1.1 Node的诞生历程1.2 Node的命名与起源 设计高性能Web服务器的几个要点：事件驱动、非阻塞I&#x2F;O。 1.3 Node给JavaScript带来的意义 Node打破了过去JavaScript只能在浏览器中运行的局面。 在Node中，JavaScript可以随心所欲地访问本地文件，可以搭建WebSocket服务端，可以连接数据库，可以如Web Workers一样玩转多进程。 1.4 Node的特点1.4.1 异步I&#x2F;O12345// 发起一个Ajax请求$.post(&#x27;/url&#x27;, &#123;title: &#x27;深入浅出Node.js&#x27;&#125;, function (data) &#123; console.log(&#x27;收到响应&#x27;); //将在异步请求结束后执行，但不知道具体的时间点&#125;);console.log(&#x27;发送Ajax结束&#x27;); “收到响应”是在“发送Ajax结束”之后输出的。 这里的“发起读取文件”是在“读取文件完成”之前输出的。 1234567// 读取文件var fs = require(&#x27;fs&#x27;);fs.readFile(&#x27;/path&#x27;,function(err,file)&#123; console.log(&#x27;读取文件完成&#x27;);&#125;);console.log(&#x27;发起读取文件&#x27;); 在Node中，绝大多数的操作都以异步的方式进行调用。每个调用之间无需等待之前的I&#x2F;O调用结束，在编程模型上可以极大提升效率。 对于异步而言，两个读取任务的耗时取决于最慢的那个文件读取的耗时。对于同步I&#x2F;O而言，它们的耗时是两个任务的耗时之和。 1.4.2 事件与回调函数 Node创建一个Web服务器，并监听8080端口。 对于服务器，我们为其绑定了request事件，对于请求对象，我们为其绑定了data事件和end事件。 1234567891011121314var http = require(&#x27;http&#x27;);var querystring = require(&#x27;querystring&#x27;);http.createServer(function(req, res)&#123; var postData = &#x27;&#x27;; req.setEncoding(&#x27;uft8&#x27;); req.on(&#x27;data&#x27;, function(trunk)&#123; postData += trunk; &#125;); req.on(&#x27;end&#x27;,function()&#123; res.end(postData); &#125;);&#125;).listen(8080);console.log(&#x27;服务器启动完成&#x27;); 相应地，我们在前端为Ajax请求定了success事件，在发出请求后，只需关心请求成功时执行相应的业务逻辑就即可。 12345678$.ajax(&#123; &#x27;url&#x27;: &#x27;/url&#x27;, &#x27;method&#x27;: &#x27;POST&#x27;, &#x27;data&#x27;: &#123;&#125;, &#x27;success&#x27;: function (data) &#123; // success事件 &#125;&#125;) Node除了异步和事件外，回调函数是一大特色。回调函数也是最好的接受异步调用返回数据的方式。 代码的编写顺序与执行顺序并无关系。 1.4.3 单线程 Node保持了JavaScript在浏览器中单线程的特点。而且在Node中，JavaScript与其余线程是无法共享任何状态的。 单线程的最大好处是不用像多线程编程那样在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换带来的性能上的开销。 单线程的弱点： 无法利用多核CPU； 错误会引起整个应用退出，应用的健壮性值得考验； 大量计算占用CPU导致无法继续调用异步I&#x2F;O。 Node采用了与Web Workers相同的思路来解决单线程中计算量的问题：子线程（child_process）。 1.4.4 跨平台 起初Node只可以在Linux平台上运行，现在Node可以借助libuv实现跨平台 1.5 Node的应用场景1.5.1 I&#x2F;O密集型 从单线程的角度来说，Node面向网络且擅长并行I&#x2F;O，能有效地组织起更多的硬件资源，从而提供更好的服务。 I&#x2F;O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。 1.5.2 是否不擅长CPU密集型业务 Node在性能上并不差，甚至表现得很优秀。 CPU密集的挑战主要是由于JavaScript单线程的原因，若有长时间运行的计算（大循环）将会导致CPU时间片不能释放，使得后续I&#x2F;O无法发起。但适当调整和分解大型运算任务为多个小任务，能使运算适时释放，不阻塞I&#x2F;O调用。 Node可以通过编写C&#x2F;C++扩展的方式更高效低利用CPU；利用子进程，将计算和I&#x2F;O分离。 1.5.3 与遗留系统和平共处1.5.4 分布式应用 阿里巴巴ࣄ开发了中间应用NodeFox、ITier，数据库及做了Ѳ分֖௡࠰,ಉលុ用Ιே是᧪对ӬषᛪᤈᛠSQLಉល，中ᫍࡎ分解ಉលSQL，并ᛠڠԜ多Ի数૵ं中ᖌԨ数૵并Ջ并。NodeFox能实ဗ对多ԻMySQL数૵ं的ಉល，ݟՎಉល一ԻMySQL一样，ᏪITierఝ强大，ಉល多个数૵ंݟՎ 1.6 Node的使用者 第2章 模块机制2.1 CommonJS规范2.1.1 CommonJS的出发点 在JavaScript的发展历程中，它主要在浏览器前端发光发热。官方规范（ECMAScript）规范化的时间较早，在实际应用中，JavaScript的表现能力取决于宿主环境中（浏览器）API支持程度。 后端JavaScript的规范远远落后，它的规范依然是薄弱的。 没有模块系统。 标准库较少。ES仅定义了部分核心库，对于文件系统I&#x2F;O流等常见需求却没有标准的API。 没有标准接口。 缺乏包管理系统。 2.1.2 CommonJS的模块规范1 模块引用 上下文提供require()方法来引入外部模块。 1var math = require(&#x27;math&#x27;); 2 模块定义 上下文提供export对象用于导出当前模块的方法或者变量，并且它事唯一导出的出口。 在模块中，还存在一个module对象，它代表模块自身，而export是module的属性。 123456789101112131415//math.jsexports.add = function()&#123; var sum = 0, i = 0, args = arguments, l = args.length; while(i &lt; l)&#123; sum += args[i++]; &#125; return sum; &#125;// program.jsvar math = require(&#x27;math&#x27;);console.log(math.add(1,2)) // 3 3 模块标识 模块标识其实就是传递给require()方法的参数，他必须是符合小驼峰命名的字符串，或者以.、..开ܿ的相对路径，或者绝对路径。每个模块具有独立的空间，互不干扰。 2.2 Node的模块实现 Node的模块机制只需要exports、require、module，但在Node中引入模块需要经历3个步骤： （1）路径分析 （2）文件定位 （3）编译执行 Node的两类模块： 核心模块（Node提供的模块）： 在Node源代码的编译过程中，编译进了二进制执行文件。在node进程启动时，部分核心模块就直接加载进内存中，所以这部分核心模块引入时，无需文件定位和编译执行，并且在路径分析中优先判断，所以它的加载速度是最快的。 文件模块（用户编写的模块）：在运行时动态加载，需要完整的三个步骤，速度比核心模块慢。 2.2.1 优先从缓存加载 Node对引入过的模块都会进行缓存，减少二次引入时的开销。 不同的地方在于，浏览器仅仅缓存文件，而Node缓存的是编译之后的对象。 核心模块的缓存检查优先于文件模块的缓存检查。 2.2.2 路径分析和文件定位1 路径分析（模块标识符分析） 对于不同的标识符，模块的查找和定位有不同程度上的差异。 模块标识符分为4类： 核心模块，如http、fs、path等。 .或..开始的相对路径文件模块。 /开始的绝对路径文件模块。 非路径形式的文件模块，如自定义的connect模块。 核心模块：核心模块的优先级仅次于缓存加载，已在Node源码编译过程编译成二进制代码，其加载过程最快。如果试图加载一个与核心模块标识符相同的自定模块，必须选择一个不同的标识符或换用路径的方式。 路径形式的文件模块：以.、..、/开始的标识符，都被当作文件模块来处理。在分析路径模块时，require()会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果放到缓存中，以便二次加载。也可以节约大量时间，因为给Node指明了确切的文件位置。 自定义模块：这类模块查找是最费时的。 模块路径：是Node在定位文件模块的具体文件时制定的查找策略，是一个路径组成的数组。可以看出，模块路径的生成规则是，原路径向上逐级递归，直到根目录下的node_modules目录。若当前文件路径越深，模块查找耗时会越多。 12345678910111213//module_path.jsconsole.log(module.paths)//以下是在MacOS下vscode的输出[ &#x27;/Users/Never/Desktop/project/nodeStudy/path/node_modules&#x27;, &#x27;/Users/Never/Desktop/project/nodeStudy/node_modules&#x27;, &#x27;/Users/Never/Desktop/project/node_modules&#x27;, &#x27;/Users/Never/Desktop/node_modules&#x27;, &#x27;/Users/Never/node_modules&#x27;, &#x27;/Users/node_modules&#x27;, &#x27;/node_modules&#x27;] 12345678910// 当前目录: /usr/local/test/index.js// gulp模块所在路径为 /usr/lib/node_modulesconsole.log(module.paths); // [&#x27;/usr/local/test/node_modules&#x27;, &#x27;/usr/local/node_modules&#x27;, &#x27;/usr/node_modules&#x27;, &#x27;/node_modules&#x27;]var gulp = require(&#x27;gulp&#x27;); // 报错“MODULE_NOT_FOUND”// 尝试修改该数组 影响本模块加载依赖的顺序module.paths.push(&#x27;/usr/lib/node_modules&#x27;); console.log(module.paths); //[&#x27;/usr/local/test/node_modules&#x27;, &#x27;/usr/local/node_modules&#x27;, &#x27;/usr/node_modules&#x27;, &#x27;/node_modules&#x27;, &#x27;/usr/lib/node_modules&#x27;]var gulp = require(&#x27;gulp&#x27;); // 运行成功，但Node会在找到gulp依赖前遍历4层目录，最后才在第五层目录中找到它 2 文件定位 文件定位主要包括文件扩展名分析、目录和包的处理 文件扩展名分析 require()在分析不包含文件扩展名的标识符时，Node会按.js、.json、.node的次序补足扩展名，依次尝试。 Node需要调用fs模块同步阻塞式地判断文件是否存在。因此若.json、.node文件，给标识符带上扩展名会更快。 目录分析和包 分析文件扩展名之后，可能没有找到对应文件，但却找到一个目录，Node则会将目录当作一个包来处理。 Node在当前目录下查找package.json，通过JSON.parse()解析出包描述的对象，从中找到main属性置顶的文件名进行定位，若缺少扩展名则会进行扩展名分析的不走。若main指定的文件错误或根本没有package.json，Node则会将index当作默认文件名，一次查找index.js、index.jsn、index.node。 若在目录分析中没有定位成功任何文件，则进入下一个模块路径进行查找，知道路径数组都被遍历完毕，还是没找到目标文件，就会抛出查找失败的异常。 2.2.3 模块编译 每个文件模块都是一个对象，定义如下：1234567891011function Module(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; if(parent &amp;&amp; parent.children) &#123; parent.children.push(this); &#125; this.filename = null; this.loaded = false; this.children = [];&#125; 编译和执行是引入模块的最后一个阶段。 第3章 异步I&#x2F;O3.13.3 Node的异步I&#x2F;O3.3.1 事件循环 Node自身的执行模型——事件循环。","categories":[{"name":"Books","slug":"Books","permalink":"http://nevvvver.github.io/categories/Books/"}],"tags":[{"name":"node","slug":"node","permalink":"http://nevvvver.github.io/tags/node/"}]},{"title":"《JavaScript权威指南(第6版)》笔记","slug":"JavaScript权威指南","date":"2022-07-11T09:27:54.000Z","updated":"2022-07-18T09:48:41.697Z","comments":true,"path":"2022/07/11/JavaScript权威指南/","link":"","permalink":"http://nevvvver.github.io/2022/07/11/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/","excerpt":"","text":"第〇部分第1章 JavaScript概述电子书：《JavaScript权威指南(第6版)》 第一部分 JavaScript 语言核心第2章 词法结构2.1 字符集第6章 对象 内置对象（native object）是由ECMAScript规范定义的对象或类。例如数组、函数、日期、正则表达式等。 宿主对象（host object）是由JavaScript解释器所嵌入的宿主环境（比如Web浏览器）定义的。 自定义对象 （user-defiend object）是由运行中的JavaScript代码创建的对象。 自有属性（own property）是直接在对象中定义的属性。 继承属性（inherited property）是在对象的原型对象中定义的属性。 6.1 创建对象对象直接量 1234567891011var empty = &#123;&#125;;var point = &#123; x:0, y:0 &#125;;var book = &#123; &quot;main title&quot;: &quot;JavaScript&quot;, &quot;sub-title&quot;: &quot;The Definitive Guide&quot;, &quot;for&quot;: &quot;all audiences&quot;, author: &#123; firstname: &quot;David&quot;, surname: &quot;Flanagan&quot; &#125;&#125; 对象直接量是一个表达式，表达式的每次运算都创建并初始化一个新的对象。 关键字new 1234var o = new Object(); // 创建一个空对象，和&#123;&#125;一样var a = new Array(); // 创建一个空数组，和[]一样var d = new Date(); // 创建一个白哦是当前时间的Date对象var r = new RegExp(&quot;js&quot;); // 创建一个可以进行模式匹配的RegExp对象 new运算符后面跟的是一个函数调用，这个函数被称为构造函数（constructor）。js中原始类型都包含内置的构造函数，也可以自己定义构造函数。 原型 每一个JavaScript对象（null除外）对合另一个对象（原型）相关联，每一个对象都从原型继承属性。 通过new Object()创建的对象也继承自Object.prototype，new Array() Object.create()（ES5） 第9章 类和模块9.1 类和原型 类的所有实例对象都从同一个原型对象上继承属性。 12345// range.js: 实现一个能表示值的范围的类// 这个工厂方法返回一个新的“范围对象”function range(from, to) &#123;&#125; 9.2 类和构造函数1234var F = function()&#123;&#125;; // 这是一个函数对象var p = F.prototype; // 这是F相关联的原型对象var c = p.constructor; // 这是与原型相关联的函数c === F // =&gt; true 12var o = new F(); // 创建类F的一个实例o.constructor === F // =&gt; true construtor属性指代这个类 对于任意函数 F.prototype.constructor === F 9.3 JavaScript中Java式的类继承 类字段、类方法；实例字段、实例方法 构造函数对象原型对象 9.5 类和类型 三种可以检测对象的类的方法：instanceof运算符、constructor属性、构造函数的名字。 三种方法都不完美，但利用鸭式辩型，可以更加关注对象可以完成什么工做而不是对象属于哪个类。 instanceof运算符 o instanceof c 返回true，表示o继承自c.prototype，这里的继承可以不是直接继承 构造函数是类的公共标识，但原型是唯一的标识。instanceof检测了对象的继承关系，而不是检测创建对象的构造函数 constructor属性-","categories":[{"name":"Books","slug":"Books","permalink":"http://nevvvver.github.io/categories/Books/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nevvvver.github.io/tags/javascript/"}]},{"title":"useReducer+useContext","slug":"useReducer-useContext","date":"2022-06-10T03:08:02.000Z","updated":"2022-07-11T09:21:40.867Z","comments":true,"path":"2022/06/10/useReducer-useContext/","link":"","permalink":"http://nevvvver.github.io/2022/06/10/useReducer-useContext/","excerpt":"","text":"学习的文章The best Couple: useContext + useReducer !Disclaimer: This is going to be one of the best post you have ever come across in search of useContext + useReducer hooks! Why do we use useContext and usereducer together? Reason: To share states between the components i.e. Global StateManagement In the previous posts, we have seen how to make use of useContext and useReducer hooks. So, in this post, we will see how to make use of them together! In this example, we are going to share the state of the counter between Component A , Component D and Component F! Also, the Components hierarchy in our example is as follows: 1.)Component A2.)Component B -&gt; Component D3.)Component C -&gt; Component E -&gt; Component F Steps: 1.) Create React context in the main component 2.) Make reducer function in the main component 3.) Make use of the useReducer function. 4.) Send context value using Context Provider 5.) Consume Context Value using useContext hook. 6.) Transfer action from the components using dispatch Okay so let’s get started! Step1: Create React Context and reducer() function: Step2: In the functional component, call useReducer(reducer,initialState) hook : Here, you can see that we have passed the state i.e. counter and dispatch method as the value in the Context Provider. Step 3: Now, in order to access the global state in Component A, Component D, and Component F, we need to make use of the useContext Hook to consume the context value passed by the Context Provider. (component A)(component D) (component F) Step 4: In order to change the global state through Components A, D, and F, we have passed action (i.e. increment, decrement, or reset) through the dispatch function. This is all you need to manage the global state using useReducer and useContext hook! I hope it might have helped you! Do share your thaughts! *Happy Coding, Thank you! * -Jayant Khandelwal 我的应用背景一个多tab选规则的面板 每个tab下面的规则不一样（规则一样，选的值可以不一样） 但是都是渲染的一个面板 只是切换tab的时候从store里拿不一样的value填进去此时有一个规则组件有校验的问题 只能存在本地 但是state存储无法存储不同tab的校验状态 所以此时用一个本地的对象来存 以每个tab规则的id来作为索引存每一个规则的校验状态比如规则1 是校验失败 规则2是校验成功这个状态是存在state的无法 如果不专门存在store里是无法区分每个规则的 1234567891011121314151617181920212223242526272829303132333435363738394041//rule-context.tsximport React, &#123; Dispatch, useReducer &#125; from &#x27;react&#x27;; type RuleProps = &#123; helpState: Record&lt;string, Record&lt;string, string&gt;&gt;; helpDispatch: Dispatch&lt;&#123; type: string; payload: &#123; id: string;code: string; help: string; flag?: string &#125; &#125;&gt;; &#125;const MdContext = React.createContext&lt;RuleProps&gt;(&#123; helpState: &#123;&#125;, helpDispatch: () =&gt; void 0,&#125;);const reducer = (state: Record&lt;string, Record&lt;string, string&gt;&gt;, action: &#123; type: string; payload: &#123; id: string; code: string; help: string; flag?: string; &#125;;&#125;) =&gt; &#123; switch (action.type) &#123; case &#x27;add&#x27;: return &#123; ...state, [action.payload.id]: &#123; ...state[action.payload.id], [action.payload.code]: action.payload.help, [`$&#123;action.payload.code&#125;Flag`]: action.payload.flag as string, &#125;, &#125;; default: return state; &#125;&#125;;const useHelpRuleReducer = () =&gt; useReducer(reducer, &#123;&#125;);export &#123; MdContext, useHelpRuleReducer &#125;; 1234567891011121314151617```javascript//rule.tsximport &#123; MdContext &#125; from &#x27;rule-context.tsx&#x27;;const &#123; helpState, helpDispatch &#125; = useContext(MdContext);//使用helpDispatch(&#123; type: &#x27;add&#x27;, payload: &#123; code, id, help: &#x27;校验失败&#x27;, &#125;, &#125;);console.log(helpState[id]?.[code])","categories":[{"name":"React","slug":"React","permalink":"http://nevvvver.github.io/categories/React/"}],"tags":[{"name":"react","slug":"react","permalink":"http://nevvvver.github.io/tags/react/"},{"name":"context","slug":"context","permalink":"http://nevvvver.github.io/tags/context/"},{"name":"reducer","slug":"reducer","permalink":"http://nevvvver.github.io/tags/reducer/"},{"name":"hooks","slug":"hooks","permalink":"http://nevvvver.github.io/tags/hooks/"}]},{"title":"jsoneditor-react的类型声明文件","slug":"jsoneditor-react的类型声明文件","date":"2022-06-07T09:25:44.000Z","updated":"2022-06-07T09:46:02.848Z","comments":true,"path":"2022/06/07/jsoneditor-react的类型声明文件/","link":"","permalink":"http://nevvvver.github.io/2022/06/07/jsoneditor-react%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6/","excerpt":"","text":"jsoneditor-react.d.ts放在src下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475declare module &#x27;jsoneditor-react&#x27; &#123; export class JsonEditor extends React.Component&lt;JsonEditorProps&gt; &#123; public jsonEditor: unknown; &#125; type Mode = &#x27;tree&#x27; | &#x27;view&#x27; | &#x27;form&#x27; | &#x27;code&#x27; | &#x27;text&#x27;; interface JsonEditorProps &#123; value: unknown; /** Set the editor mode. Default &#x27;tree&#x27; */ mode?: Mode; /** Initial field name for root node */ name?: string; /** Validate the JSON object against a JSON schema. */ schema: unknown; /** Schemas that are referenced using the $ref property */ schemaRefs?: object; /** * If true, object keys in &#x27;tree&#x27;, &#x27;view&#x27; or &#x27;form&#x27; mode list be listed alphabetically * instead by their insertion order. * */ sortObjectKeys?: boolean; /** Set a callback function triggered when json in the JSONEditor change */ onChange?: (value: object[]) =&gt; void; /** * Set a callback function triggered when an error occurs. * Invoked with the error as first argument. * The callback is only invoked for errors triggered by a users action, * like switching from code mode to tree mode or clicking * the Format button whilst the editor doesn&#x27;t contain valid JSON. */ onError?: (error: unknown) =&gt; void; /** Set a callback function triggered right after the mode is changed by the user. */ onModeChange?: (mode: Mode) =&gt; void; onClassName?: (args: &#123; path: unknown; field: unknown; value: unknown &#125;) =&gt; void; /** Provide a version of the Ace editor. Only applicable when mode is code */ ace?: object; /** Provide a instance of ajv,the library used for JSON schema validation. */ ajv?: object; /** Set the Ace editor theme, uses included &#x27;ace/theme/jsoneditor&#x27; by default. */ theme?: string; /** * Enables history, adds a button Undo and Redo to the menu of the JSONEditor. * Only applicable when mode is &#x27;tree&#x27; or &#x27;form&#x27;. Default to false */ history?: boolean; /** * Adds navigation bar to the menu * the navigation bar visualize the current position on the * tree structure as well as allows breadcrumbs navigation. Default to true */ navigationBar?: boolean; /** * Adds status bar to the buttom of the editor * the status bar shows the cursor position and a count of the selected characters. * Only applicable when mode is &#x27;code&#x27; or &#x27;text&#x27;. Default to true */ statusBar?: boolean; /** Enables a search box in the upper right corner of the JSONEditor. Default to true */ search?: boolean; /** Create a box in the editor menu where the user can switch between the specified modes. */ allowedModes?: Mode[]; /** Html element, or react element to render */ tag?: string | HTMLElement; /** html element custom props */ htmlElementProps?: object; /** callback to get html element reference */ innerRef?: (ref: unknown) =&gt; void; &#125;&#125;","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://nevvvver.github.io/categories/TypeScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nevvvver.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://nevvvver.github.io/tags/es6/"}]},{"title":"可枚举性(enumerable)","slug":"enumerable","date":"2022-03-14T18:53:58.000Z","updated":"2022-03-15T16:09:02.657Z","comments":true,"path":"2022/03/15/enumerable/","link":"","permalink":"http://nevvvver.github.io/2022/03/15/enumerable/","excerpt":"","text":"描述 在 JavaScript 中，对象的属性可以分为实例属性和原型 (prototype) 属性。 实例属性：指的是自身属性。 原型属性：指的是从原型链上继承的属性。 Object.prototype.hasOwnProperty() 可以判断某一个属性是否是对象的自身属性。 对象的每一个属性都有一个描述对象 (Descriptor) ,描述对象的 enumerable 属性称为“可枚举性”。 引入“可枚举性”这个概念的最初目的，就是让某些属性可以规避掉 for...in 操作。 可枚举性的作用与可枚举性有关的操作： 函数方法 描述 实例属性 原型属性 for...in 遍历对象自身和原型上的所有可枚举属性 〇 〇 Object.keys() 返回对象自身的所有可枚举属性的键名 〇 JSON.stringify 只串行化对象自身的所有可枚举属性 〇 Object.assign()(ES6) 只拷贝对象自身的所有可枚举属性 〇 Object.getOwnPropertyNames() 返回对象自身的所有属性的键名 〇 code samples123456789101112131415function Person() &#123; this.name = &quot;Never&quot;;&#125;;// 通过直接的赋值和属性初始化的属性，可枚举性默认为truePerson.prototype.School = &#x27;Tust&#x27;;let person = new Person();// 通过 Object.defineProperty() 等定义的属性，可枚举性默认为falseObject.defineProperty(person, &quot;sex&quot;, &#123; value: &quot;male&quot;, // enumerable: false&#125;); 12345678910111213Object.keys(person).forEach(function(key) &#123; console.log(key) // name&#125;);for(var p in person)&#123; console.log(p); // name, School&#125;Object.getOwnPropertyNames(person).forEach(function(key) &#123; console.log(key)// name, sex&#125;); 如何判断属性是否可枚举 Object.propertyIsEnumerable() 方法可以判断一个属性是否是对象的可枚举的自身属性。（注：如果判断的属性是原型属性，不管它是否可枚举都会返回false） 123person.propertyIsEnumerable(&#x27;name&#x27;); // trueperson.propertyIsEnumerable(&#x27;School&#x27;); // falseperson.propertyIsEnumerable(&#x27;sex&#x27;); // false","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://nevvvver.github.io/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://nevvvver.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://nevvvver.github.io/tags/es6/"}]},{"title":"testcomment","slug":"testcomment","date":"2022-03-09T09:35:39.000Z","updated":"2022-03-09T09:35:39.288Z","comments":true,"path":"2022/03/09/testcomment/","link":"","permalink":"http://nevvvver.github.io/2022/03/09/testcomment/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[{"name":"Books","slug":"Books","permalink":"http://nevvvver.github.io/categories/Books/"},{"name":"React","slug":"React","permalink":"http://nevvvver.github.io/categories/React/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://nevvvver.github.io/categories/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://nevvvver.github.io/categories/JavaScript/"}],"tags":[{"name":"node","slug":"node","permalink":"http://nevvvver.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"http://nevvvver.github.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://nevvvver.github.io/tags/react/"},{"name":"context","slug":"context","permalink":"http://nevvvver.github.io/tags/context/"},{"name":"reducer","slug":"reducer","permalink":"http://nevvvver.github.io/tags/reducer/"},{"name":"hooks","slug":"hooks","permalink":"http://nevvvver.github.io/tags/hooks/"},{"name":"es6","slug":"es6","permalink":"http://nevvvver.github.io/tags/es6/"}]}