{"meta":{"title":"Never","subtitle":"","description":"","author":"Never","url":"https://Nevvvver.github.io","root":"/"},"pages":[{"title":"分类","date":"2022-03-14T19:37:47.600Z","updated":"2022-03-14T19:37:47.600Z","comments":false,"path":"categories/index.html","permalink":"https://nevvvver.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-03-14T19:30:14.438Z","updated":"2022-03-14T19:30:14.438Z","comments":false,"path":"tags/index.html","permalink":"https://nevvvver.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"webpack5新特性","slug":"webpack5新特性","date":"2022-09-15T09:35:49.000Z","updated":"2022-10-13T09:41:52.834Z","comments":true,"path":"2022/09/15/webpack5新特性/","link":"","permalink":"https://nevvvver.github.io/2022/09/15/webpack5%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"1 启动命令 webpack4 启动 devServer，用的命令是 webpack-dev-server webpack5 启动 devServer，用的命令是 webpack serve 2 持久化缓存持久化缓存是 webpack5 所带来的非常强大的特性之一。 webpack5 通过将构建结果持久化缓存到本地磁盘，使之在二次构建时可以直接利用磁盘缓存跳过构建过程当中耗时的流程，大大提升编译构建的效率，优化编译流程。 之前的持久缓存方式 使用 cache-loader 可以将上一个 loader 处理的结果写入硬盘缓存（默认在 node_modules&#x2F;.cache&#x2F;cache-loader 目录），webpack 再次构建时如果文件没有发生变化则会直接拉取缓存。但是 cache-loader 缓存是在构建流程当中进行的 只能覆盖由 loader 处理后的文件内容，缓存数据的过程也是有一些性能开销的，也会影响整个的编译构建速度，所以搭配编译耗时较长的 loader 一起使用更划算。 1234567891011module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.js$/, use: [&#x27;cache-loader&#x27;, &#x27;babel-loader&#x27;], include: path.resolve(&#x27;src&#x27;) &#125; ] &#125;&#125;; 还有一部分 loader 自带缓存配置，比如 babel-loader，可以配置参数 cacheDirectory 使用缓存，将每次的编译结果写进磁盘（默认在 node_modules&#x2F;.cache&#x2F;babel-loader 目录） 1234567891011121314module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.js$/, use: &#123; loader: &#x27;babel-loader&#x27;, cacheDirectory: true, &#125; include: path.resolve(&#x27;src&#x27;) &#125; ] &#125;&#125;; terser-webpack-plugin 开启缓存 123456789module.exports = &#123; optimization: &#123; minimizer: [ new TerserPlugin(&#123; cache: true &#125;) ] &#125;,&#125;; eslint-loader 同样支持缓存功能，只需设置 cache &#x3D; true 即可开启。 123456789101112module.exports = &#123; module: &#123; rules: [&#123; test: /\\.js$/, exclude: /node_modules/, loader: &#x27;eslint-loader&#x27;, options: &#123; cache: true, &#125;, &#125;] &#125;,&#125;; webpack5 的持久缓存方式原理如下图，是 Webpack5 的构建过程，在首次构建完毕后，会将 Module、Chunk、ModuleGraph 等对象序列化后记录到缓存文件中。构建过程中存在许多 CPU 密集型操作，例如调用 Loader 链加载文件时，遇到 babel-loader、eslint-loader、ts-loader 等工具时可能需要重复生成 AST；分析模块依赖信息时则需要遍历 AST，执行大量运算；生成（Seal）阶段也同样存在大量 AST 遍历，以及代码转换、优化操作等等。 在下次构建开始时，尝试读入并恢复这些序列化对象的状态，从而跳过执行 Loader 链、解析 AST、解析依赖等耗时操作，提高编译性能。未发生变化的文件就可以跳过编译操作，直接使用缓存副本，减少重复计算；发生变更的模块则重新执行编译流程。缓存执行时机如下图： cachecache 在 Webpack 4 中只是单个属性的配置，所对应的值为 true 或 false，而在webpack5增加了许多子配置项。默认不开启。 下面介绍几个 cache 常用的配置项： cache.type：缓存类型。支持 ‘memory’ | ‘filesystem’，分别代表基于内存的临时缓存，以及基于文件系统的持久化缓存。在选择 filesystem 的情况下，下面介绍的其他属性生效。 cache.cacheDirectory：缓存文件存放的路径。默认目录为 node_modules&#x2F;.cache&#x2F;webpack cache.name：缓存名称。同时也是 cacheDirectory 中的子目录名称，默认值为 webpack 的 $&#123;config.name&#125;-$&#123;config.mode&#125; cache.buildDependencies：额外的依赖文件，当这些文件内容发生变化时，缓存会完全失效而执行完整的编译构建，通常可设置为项目配置文件。 cache.version：缓存数据的版本。 cache.managedPaths：受控目录，Webpack 构建时会跳过新旧代码哈希值与时间戳的对比，直接使用缓存副本，默认值为 [‘.&#x2F;node_modules’] cache.profile：是否输出缓存处理过程的详细日志，默认为 false cache.maxAge：缓存失效时间，默认值为1个月 12345678910module.exports = &#123; ... cache: &#123; type: &#x27;filesystem&#x27;,// &#x27;memory&#x27; | &#x27;filesystem&#x27; cacheDirectory: path.resolve(__dirname, &#x27;node_modules/.cache/webpack&#x27;) buildDependencies: &#123; config: [__filename], &#125;, &#125;,&#125;; 更多关于 cache 的配置可前往官网 内容哈希（contentHash）在 webpack5 里会使用文件内容的真实哈希 [contenthash]，而不是之前的仅仅使用文件内部结构的哈希，这对于长期缓存有着积极的影响，尤其是代码里面只有注释和变量名修改的时候，webpack5 会继续用之前的缓存而不是重新编译。 如下，在 webpack4 中使用 [contenthash] 修改注释后虽然文件内容没变但是却重新编译生成了新的哈希。 在 webpack5 中我们对如下文件进行编译，这是第一次生成的[contenthash] 更改变量名再次编译，可以看到我们的哈希值并没有变化 修改注释再次编译，可以看到我们的哈希值仍然没有变化 moduleIds &amp; chunkIds 的优化在 webpack5 之前，没有从 entry 打包的 chunk 文件，都会以1、2、3…的文件命名方式输出，是自增的，删除某些文件可能会导致缓存失效。如下图所示，打包后的文件名1、2、3分别对应 ModuleA、ModuleC、ModuleC 若我们不引入 ModuleB，你会发现 1、2 分别对应着ModuleA、ModuleC，这是不稳定的。 webpack5 新增了长期缓存的算法，在生产模式下是默认启用的。此算法采用确定性的方式将短数字 ID(3 或 4 个字符)短hash值分配给 modules 和 chunks。 1234optimization: &#123; chunkIds: &quot;deterministic&quot; moduleIds: &quot;deterministic&quot;&#125; 如下图所示，打包后的文件名664、300、761分别对应 ModuleA、ModuleC、ModuleC 若我们不引入 ModuleB，你会发现 664、761 分别对应着ModuleA、ModuleC，是确定的。 单个模块的缓存失效Webpack 5 会跟踪每个模块的依赖项：fileDependencies、contextDependencies、missingDependencies。当模块本身或其依赖项发生变更时，Webpack 能找到所有受影响的模块，并重新进行构建处理。 这里需要注意的是，对于 node_modules 中的第三方依赖包中的模块，出于性能考虑，Webpack 不会跟踪具体模块文件的内容和修改时间，而是依据依赖包里package.json 的 name 和 version 字段来判断模块是否发生变更。因此，单纯修改 node_modules 中的模块内容，在构建时不会触发缓存的失效。 全局缓存失效当模块代码没有发生变化，但是构建处理过程本身发生变化时（例如升级了 Webpack 版本、修改了配置文件、改变了环境变量等），也可能对构建后的产物代码产生影响。因此在这种情况下不能复用之前缓存的数据，而需要让全局缓存失效，重新构建并生成新的缓存。在 Webpack 5 中共提供了 3 种不同维度的全局缓存失效配置。 1. buildDependencies 第一种配置是 cache.buildDependencies，用于指定可能对构建过程产生影响的依赖项。 &#123;defaultWebpack: [&quot;webpack/lib&quot;]&#125;: 默认选项。当 node_modules 中的 Webpack 或 Webpack 的依赖项（例如 watchpack 等）发生变化时，当前的构建缓存即失效。 &#123;config: [__filename]&#125;: 它的作用是当配置文件内容或配置文件依赖的模块文件发生变化时，当前的构建缓存即失效。 2. version 第二种配置是 cache.version。当配置文件和代码都没有发生变化，但是构建的外部依赖（如环境变量）发生变化时，预期的构建产物代码也可能不同。这时就可以使用 version 配置来防止在外部依赖不同的情况下混用了相同的缓存。 例如，你的 config 读取环境变量 GIT_REV 并且使用 DefinePlugin 来嵌入打包. 我们就可以将 GIT_REV 作为依赖。可以传入 cache: &#123;version: process.env.GIT_REV&#125;。 3. name 第二种配置是 cache.name。该名称除了作为默认缓存目录下子目录的名称外，也起到区分缓存数据的作用。例如，可以传入 cache: &#123;name: process.env.NODE_ENV&#125;。 需要注意的是: 与 version 或 buildDependencies 等配置不同，name 在默认情况下是作为缓存的子目录名称存在的，因此可以利用 name 保留多套缓存。在 name 切换时，若已存在同名称的缓存，则可以复用之前的缓存。如下，可以通过 name 保存多套缓存。 与之相比，当其他配置发生变化时，会直接将之前的缓存失效，即使切换回之前已缓存过的设置，也会当作无缓存处理。 构建结果对比Webpack4首次编译 二次编译 修改 index.js 的一行代码 devServer 启动 不关闭 devServer 修改index.js的一行代码 Webpack5首次编译 二次编译可以看到第二次编译时一共149个 modules 全部来自缓存 修改 index.js 的一行代码可以看到除了 index.js 重新构建外，其他的140个 modules 全部来自缓存 devServer 启动 不关闭 devServer 修改 index.js 的一行代码 对比结果 webpack版本 首次编译 无改动二次编译 修改后的二次编译 启动server 修改后的二次编译 v4 2919ms 1392ms 2467ms 3944ms 2396ms v5 3793ms 658ms 1094ms 2500ms 72ms webpack5 相对于 webpack4，首次构建速度的会慢一些，因为 webpack5 还需要进行缓存相关的操作。但是我们可以看到在无修改的二次编译时 webpack5 相较于 webpack4 速度大大提升，快了近52%。在 devServer 中的增量编译效果更明显，快了近97%，因为 server 在启动后的编译无需再初始化了（如 loader、plugin 的初始化），所以速度更快。我进行这个实验的代码量很少，相信在庞大的项目中还会有更好的效果。 3 资源模块资源模块是一种模块类型，Webpack5 提供了内置的静态资源（图片、字体、图标等）构建能力，我们不需要安装额外的 loader，仅需要简单的配置就能实现静态资源的打包和分目录存放。 在 Webpack5 之前，我们一般都会使用以下几个 loader 来处理一些常见的静态资源： raw-loader：将文件导入为字符串。 file-loader：将文件打包导到输出目录，并在 import 的时候返回一个文件的 URI 将文件作为 data URI 内联到 bundle 中。 url-loader：当文件大小达到一定要求的时候，可以将其处理成 base64 的 URIS ，内置 file-loader，将文件发送到输出目录。 12345678910111213141516module.exports = &#123; module: &#123; rules: [&#123; test: /\\.(png|gif|jpe?g)$/i, use: &#123; // loader: &#x27;file-loader&#x27;, loader: &#x27;url-loader&#x27;, options: &#123; // 指定图片大小，小于该数值的图片，会被转成 base64 limit: 8 * 1024, // 8kb name: &#x27;image/[name].[ext]&#x27;, &#125; &#125; &#125;] &#125;&#125; 资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader： asset/resource 发送一个单独的文件并导出URL。之前通过使用 file-loader 实现。 asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。 asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。 asset 可以在导出一个 data URI 和 发送一个单独的文件之间自动选择，可以通过parser配置资源体积限制。 1234567891011121314151617181920module.exports = &#123; module: &#123; rules: [&#123; test: /\\.(png|gif|jpe?g)$/i, type: &#x27;asset&#x27;, // 现在，webpack 将按照默认条件，自动地在 resource 和 inline 之间进行选择： // 小于 8kb 的文件，将会视为 inline 模块类型，否则会被视为 resource 模块类型。 // 自定义设置 parser: &#123; dataUrlCondition: &#123; maxSize: 8 * 1024, &#125;, &#125;, generator: &#123; // 该[ext]已经包含了一个点 filename: &#x27;image/[name][ext]&#x27;, &#125;, &#125;] &#125;&#125; 另外 webpack 输出的 data URI 默认是使用 base64 算法编码的文件内容，如果要使用自定义编码算法，可以指定一个自定义函数来编码文件的内容，如下： 12345678910111213141516const svgToMiniDataURI = require(&#x27;mini-svg-data-uri&#x27;);module.exports = &#123; module: &#123; rules: [&#123; test:/\\.svg/, type: &#x27;asset/inline&#x27;, generator: &#123; dataUrl: content =&gt; &#123; content = content.toString(); return svgToMiniDataURI(content); &#125; &#125; &#125;] &#125;,&#125;; 更多关于资源模块的配置可前往官网 4 更智能的 tree shakingTree Shaking 通常用于描述移除 JavaScript 上下文中的未引用代码 (dead-code)。以达到减小体积，缩短 http 请求时间，起到一定效果的页面优化。 webpack4 中 Tree Shaking 的局限性 引入的模块需要是 ES6 类型的，CommonJS 类型的则不支持。 引入方式不能使用 default。export default 会导致 Tree Shaking 失败，简单来说就是 export default 打包后会作为一个对象整体。webpack 只会分析顶层对象的使用情况，并不会分析对象中的属性，所以 export default 要么就是整体引入，要么就是整体删除。 12345678// ./src/inner_module.jsconst a = &#x27;inner_a&#x27;const b = &#x27;inner_b&#x27;export &#123; a , b &#125;// ./src/index.jsimport * as inner from &#x27;./inner-module&#x27;console.log(inner.b) 没有使用 export default，可以正常进行 Tree Shaking，产物中只剩下 inner_b。 12345678// ./src/inner_module.jsconst a = &#x27;inner_a&#x27;const b = &#x27;inner_b&#x27;export default &#123; a , b &#125;// ./src/index.jsimport inner from &#x27;./inner-module&#x27;console.log(inner.b) 使用 export default后，Tree Shaking 失效，产物中留下了 inner_a、inner_b。 webpack4 主要是找 import 进来的变量是否在这个模块内出现过，出现过的不剔除，剔除没出现过的。这种方式往往作用不大，因为一般不会去 import 一个没有用到的变量。现在的编辑器和 lint 工具都会提示你去删掉无用的变量。 123456789101112131415161718192021// ./index.js（入口文件）import &#123; cube &#125; from &#x27;./math&#x27;;console.log(cube(2));// ./math.jsimport &#123; pow &#125; from &#x27;./utils&#x27;;export function square(x) &#123; return pow(x);&#125;export function cube(x) &#123; return x * x * x;&#125;// ./utils.jsexport function pow(x) &#123; return x * x;&#125; export function plus(x, y) &#123; return x + y;&#125; 以上是对应的依赖关系图和打包后的产物，根据 import 进来的变量是否在这个模块内出现过的原理分析，这里 cube 在 ./index 中被用到，会被打包。而 pow 在 ./math.js 中被用到，也会被打包。但实际上从入口 ./index.js 来看的话，pow 并不需要，因为依赖 pow 的 square 并没有被用到。但是 webpack 并不知道这一点，因为它没有做相应的作用域分析，去判断模块中导出内容与导入内容间的连接关系。 引用第三方依赖包的情况下，对应的 package.json 需要设置 sideEffects: false 来表明无副作用。webpack4 默认地将所有代码视为有副作用，这可以保护你免于删除必要的文件，但这意味着 webpack4 的默认行为实际上是不进行 Tree Shaking。 webpack5 的 TreeShakingwebpack5 的 Tree Shaking 更精细化，可以根据作用域之间的关系来进行优化，分析模块的引用关系。直接分析到哪些变量有效地用到了，就打包哪些变量。 usedExports在 Webpack5 中，Tree Shaking 在生产环境下默认启动（usedExports + Terser）。 如果想在开发环境启动 Tree Shaking，需要如下配置： 12345678optimization: &#123; usedExports : true // 标记出未被导出的变量 &quot;unused harmony export&quot; minimize : true // 去除无用变量并压缩代码 // 默认使用 Terser 进行压缩，也允许你定制自己的压缩工具 // minimize = true 时，配置才生效 minimizer: [new TerserPlugin()] &#125; usedExports 用于在 webpack 编译过程中启动标记功能，它会将每个模块中没有被使用过的导出内容标记为 unused，然后配合 Terser 将没用的函数在打包的时候删掉（会删除导出语句和这个模块）。可以说，真正执行 Tree Shaking 操作的是 Terser 插件。webpack5 内置了 terser-webpack-plugin 插件，无需自己安装。 sideEffects导出后没有使用，只是做了一个 import，那么这个 import 是没意义的，所以这个 import 语句 和 import 的文件都应该被去掉，这就要用到 sideEffects。 side effect（副作用）指当调用函数时，除了返回函数值之外，还产生了附加的影响（例如修改全局变量等），不能仅仅通过 export 判断有无意义。因此实现 Tree shaking 还有一个方式是跳过整个模块&#x2F;文件，直接查看该文件是否有副作用。sideEffects 就是用于告知 webpack 哪些模块具有副作用。 sideEffects 可配置在 package.json 和 webpack 中 在 webpack 中配置表示是否开启副作用功能。告知 webpack 去辨识 package.json 中的副作用标记或规则，以去掉那些导出不被使用且被标记不包含副作用的模块。 12345optimization: &#123; // 以下配置可以开启副作用功能 // 在开发模式下默认关闭（生产模式默认开启） sideEffects: true // true | false&#125; 在 package.json 中配置true：（默认值）这意味着所有的文件都有副作用，没有一个文件可以 Tree shaking。false：告诉 Webpack 所有文件都没有副作用，所有文件都可以 Tree shaking。数组：除了数组中包含的文件外，其他任何文件都没有副作用。除了指定的文件之外，其他文件都可以安全地进行 Tree shaking。 例如全局 css 样式，import 了但没有使用，若设置了 sideEffect: false 就会被认为没有副作用且被删掉，所以我们可以配置 sideEffect: [&quot;**.css&quot;] 要设置 css 文件有副作用还可以在 webpack 里的 loader 中进行配置，如下代码就可以指定所有的 css 都是有副作用的。 1234567module: &#123; rules: [&#123; test: /\\.css$/i, use:[], sideEffects: true &#125;]&#125; Nested Tree Shakingwebpack5 增加了对嵌套模块的导出跟踪功能，能够找到那些嵌套在最内层而未被使用的模块属性。例如下面的示例代码，webpack5 能够跟踪对导出的嵌套属性的访问，因此可以改善重新导出命名空间对象时的 Tree Shaking。 123456789101112//./src/inner-module.jsexport const a = &#x27;inner_a&#x27;export const b = &#x27;inner_b&#x27;//.src/nested-module.jsimport * as inner from &#x27;./inner-module&#x27;const nested = &#x27;nested&#x27;export &#123; inner, nested &#125;//./src/index.jsimport * as nested from &#x27;./nested-module&#x27;console.log(nested.inner.a) 这是在 webpack4 生产环境执行的构建，可以看到 inner_a、inner_b 都被保留了，这是因为在 nested-module 中，他们作为一个整体被 import ，且被使用了（被 export 了）。 这是在 webpack5 生产环境执行的构建，在构建后的结果代码中只包含了引用的内部模块的一个属性 inner_a，而忽略了不被引用的内部模块和中间模块的其他属性。 Inner Module Tree Shaking除了上面对嵌套引用模块的依赖分析优化外，webpack5 中还增加了分析模块中导出项与导入项的依赖关系的功能，即上面提到的作用域分析，从而找到更多未被使用的导入模块并加以移除。通过选项 optimization.innerGraph 进行配置，该选项在生产环境下默认开启，在开发环境下默认关闭。 在 webpack5 开发环境下构建下面的示例代码： 123456789101112131415161718192021//./src/inner-module.jsexport const a = &#x27;inner_a&#x27;export const b = &#x27;inner_b&#x27;//.src/nested-module.jsimport * as inner from &#x27;./inner-module&#x27;const nested = &#x27;nested&#x27;export &#123; inner, nested &#125;// 增加下面代码const useB = function () &#123; return inner.b&#125;export const usingB = function () &#123; return useB()&#125;//./src/index.jsimport * as nested from &#x27;./nested-module&#x27;console.log(nested.inner.a) optimization.usedExports = trueoptimization.innerGraph = false（默认）optimization.minimize = true optimization.usedExports = trueoptimization.innerGraph = trueoptimization.minimize = true 当我们在 nested-module.js 中新增了导出项 usingB，该导出项间接依赖导入项 inner.b，而这一导出项在入口模块中并未使用。在关闭 innerGraph 的情况下，构建后会发现间接引用的导出项没有被移除，该导出项间接引用的 inner.b 也被保留到了产物代码中。但是如果将优化项 innerGraph 开启，构建完成后只保留真正被使用的 inner.a。 它从入口遍历所有模块形成依赖图，并将它们捆绑在一起（bundles）。同时，webpack 知道那些导出被使用。不如我们遍历所有的作用域并将其进行分析，消除未使用的范围和模块的方法。事实上，我们可以把 scope 看作是图中的一个节点。 将上面的代码在 webpack5 中打包，square 和 pow 相关，但如果 square 不会由另一个模块导入，那么 square 连同 pow 都会被消除，可以看到在产物中 pow 和 plus都被标记为 unused。 CommonJS Tree Shakingwebpack5 中增加了对一些 CommonJS 风格模块代码的静态分析功功能： 支持 exports.xxx、this.exports.xxx、module.exports.xxx 语法的导出分析。 支持 Object.defineProperty(exports, &quot;xxxx&quot;, ...) 语法的导出分析。 支持 require(&#39;xxxx&#39;).xxx 语法的导入分析。 例如下面的代码： 12345678910//./src/module.jsexports.a = 11this.exports.b = 22module.exports.c = 33console.log(&#x27;module&#x27;)//./src/index.jsconst a = require(&#x27;./module&#x27;).aconsole.log(a) 可以看到产物代码中只有被引入的属性 a 和 console 语句，而其他两个导出属性 b 和 c 已经在产物中被排除了。 5 nodeJs的polyfill脚本被移除webpack5 以前，webpack 会包含 nodejs 核心模块的 polyfill，这样的话，比如安装了一个crypto模块，那么就可以直接使用，因为 node 的polyfill会自动启动。 现在 webpack5 不再为 Node.js 模块自动引用 Polyfills（Polyfills是一个语法检查的模版工具），需要手动添加适合的 Polyfills。 如果你想要使用类似 crypto 的 nodejs 核心模块，那么可以在 webpack 配置文件的 resolve 中配置 fallback，配置了就可以使用了，如下： 1234567891011module.exports = &#123; ... resolve: &#123; fallback: &#123; // 如果不需要，直接改为 false 就可以了 &quot;crypto&quot;: require.resolve(&quot;crypto-browserify&quot;), &quot;buffer&quot;: require.resolve(&quot;buffer&quot;), &quot;stream&quot;:require.resolve(&quot;stream-browserify&quot;) &#125; &#125;&#125; 6 模块联邦（Module Federation）https://webpack.docschina.org/concepts/module-federation/模块联邦是 webpack5 新内置的一个重要功能，它允许多个 webpack 一起工作，可以让跨应用间真正做到模块共享。解决了独立应用之间代码共享问题，能在项目内动态加载其他项目的代码，因此每个项目可以单独开发和部署它们。 模块联邦本身是一个普通的 webpack 插件 ModuleFederationPlugin，这个插件有几个重要参数：name 当前应用名称。（供调用方使用）filename 打包后的文件名称。（供调用方使用）exposes 表示导出的模块，只有在此申明的模块才可以作为远程依赖被使用。（暴露模块）remotes 导入模块，可以将其他项目的 name 映射到当前项目中。（模块使用方）shared 是非常重要的参数，可以配置共享的组件，一般是对第三方库做共享使用。如果配置了这个属性。webpack 在加载的时候会先判断本地应用是否存在对应的包，如果不存在，则加载远程应用的依赖包。 实操案例解析我们先创建两个应用 app1、app2：我们让 app1 作为模块提供方（remote），而 app2 就作为模块的消费方（host）。 并导出，在app2中分别引入app1的这两个组件。 app1 在 app1 中定义两个组件 sitename 和 info 1234567891011121314151617181920212223242526// ./src/index.jsimport sitename from &#x27;./sitename&#x27;;const title = siteName(&#x27;APP1&#x27;);document.body.append(title);// ./src/sitename.jsexport default (name) =&gt; &#123; console.log(&#x27;来自App1的模块：sitename&#x27;); const ele = document.createElement(&#x27;h3&#x27;); ele.textContent = name; return ele;&#125;// ./src/info.jsexport default () =&gt; &#123; console.log(&#x27;来自App1的模块：info&#x27;); const ele = document.createElement(&#x27;h3&#x27;); ele.textContent = &#x27;模块联邦是 webpack5 新内置的一个重要功能， 它允许多个 webpack 一起工作，可以让跨应用间真正做到模块共享。&#x27;; return ele;&#125; 创建 webpack.config.js 文件，将 sitename 和 info 暴露出去，以便提供给消费方使用，配置文件如下： 12345678910111213141516171819202122232425const Mfp = require(&#x27;webpack&#x27;).container.ModuleFederationPlugin;module.exports = &#123; ... // 开发服务器 devServer: &#123; static: path.resolve(__dirname, &#x27;output&#x27;), port: 8800, &#125;, plugins: [ ... new Mfp(&#123; // 应用名称（给调用方使用） name: &#x27;app1_remote&#x27;, // 调用方引入的文件名称 filename: &#x27;app1.js&#x27;, // 暴露模块 exposes: &#123; // 模块名称：模块文件路径 &#x27;./sitename&#x27;: &#x27;./src/sitename.js&#x27;, &#x27;./info&#x27;: &#x27;./src/info.js&#x27; &#125; &#125;) ] &#125; app2 创建 webpack.config.js 文件，在 remotes 中引入 app1 中的模块 app1_remote：app1_remote@http://localhost:8800/app1.js，app1_remote 需要和 app1 中配置的 name 一致，这个是唯一标识。 123456789101112131415161718module.exports = &#123;// 开发服务器devServer: &#123; static: path.resolve(__dirname, &#x27;output&#x27;), port: 8801,&#125;,// 插件配置plugins: [ ... new Mfp(&#123; // 导入模块 remotes: &#123; // 导入别名: 远程应用名称@远程应用地址/远程导出文件的名称 appone: &quot;app1_remote@http://localhost:8800/app1.js&quot;, &#125; &#125;)]&#125; 在 app2 中异步引入这两个组件 sitename 和 info。 1234567891011// ./src/index.jsimport(&#x27;appone/sitename&#x27;).then(res =&gt; &#123; const title = res.default(&#x27;在APP2中用sitename创建的&#x27;); document.body.append(title);&#125;)import(&#x27;appone/info&#x27;).then(res =&gt; &#123; const title = res.default(); document.body.append(title);&#125;) 然后我们分别启动这两个应用： app1的页面app2的页面 热插拔：在不关闭 server 的情况下 我们在 app1 中改动 sitename 模块中的内容。 1234// ./src/sitename.js...ele.textContent = name + &#x27;我改动了&#x27;;... 然后刷新 app2 的页面会发现页面已经及时更新了。 公共库的提取 首先我们在 app1 的 sitename 组件中使用 jquery。 1234567891011121314// ./src/sitename.jsexport default (name) =&gt; &#123; console.log(&#x27;来自App1的模块：sitename&#x27;); const ele = document.createElement(&#x27;h3&#x27;); ele.textContent = name; // 加入下面代码 import(&#x27;jquery&#x27;).then((res)=&gt;&#123; console.log(res) &#125;); return ele;&#125; 在 app2 中也使用 jquery。 123456...// ./src/index.js// 加入下面代码import(&#x27;jquery&#x27;).then((res)=&gt;&#123; console.log(res)&#125;); 可以看到 jquery 加载了两次，分别在本地 :8801 和远程 sitename 模块中使用的 :8800 也加载了一次。 在 app1 和 app 中的都加入如下 shared 配置，然后关闭 server 重新启动。 123456789new Mfp(&#123; ... shared: &#123; jquery: &#123; requiredVersion: &#x27;^3.6.1&#x27;, singleton: true, &#125; &#125;&#125;) 可以看到此时 jquery 只加载一次且加载的是本地的 jquery（:8801）而不是远程模块的。 原理提供方（remote）打包后的文件接下来我们来看提供方（remote），也就是 app1 打包后的文件列表： app.js 是远程入口文件，其他 webpack 构建使用、访问本项目暴露的模块时，须通过它来加载。 main.js 是本项目的入口文件。 src_info_js.js 和 src_sitename_js.js 是暴露的模块，供其他项目消费。 提供方（remote）远程入口文件提供方（remote）的统一访问入口文件 app1.js 负责维护管理加载共享模块。 当我们在消费方（host）执行 import(&#39;appone/sitename&#39;) 时，app2 会载入这个文件然后引入 sitename 组件。 container.get(./sitenname) 会从 __webpack_modules__ 里面拿到加载组件的方法，执行 webpack_require.e，并返回 promise。具体源码如下： moduleMap 是具体业务组件以及对应组件的加载策略。get 外部应用调用 get 方法加载具体业务组件。init 处理全局依赖共享的问题，处理共享模块的全局依赖，比如 jquery 模块。 消费者（host）如何加载远程入口文件app2 如何载入 app1 的 app1.jsimport(&#39;appone/sitename&#39;) 在 app2 打包后会编译成如下代码： webpack_require.e 作为加载远程 chunk 的方法，可与 webpack_require 加载本地脚本进行对比。 这里遍历执行 webpack_require.f 里面的方法并收集返回的 promise，当所有的 promise 都完成时意味着这个远程的模块已经加载到内存里面了，注册进 webpack_modules 这个全局模块缓冲池里面了。 与其他共享代码方案比较module两种，本地构建的模块(local module)、运行时容器加载的远程模块(remote module)。 模块联邦并没有样式隔离机制, 这意味着, 当主子应用很有可能会互相造成样式污染.但缺点公用全局变量和全局style，以及将模块暴露在全局变量下不够优雅。让代码直接在项目间利用 CDN 直接共享比如我们在开发两个应用A和B，A应用需要引用B应用，假设这两个应用是两个人开发的，都处于开发阶段，那么这时候就可以通过webpack的模块联邦Module Federation，将B应用暴露出去，然后A应用引用B应用。这样就不需要每次B应用build完了给A，直接可以同步开发。 使用模块联邦，每个应用块都应该是一个独立的构建，这些构建都将编译成容器，容器可以被其他应用或容器使用，引用模块的引用者成为host，一个被引用的容器成为remote。 有点类似微前端，其实微前端方案中确实也有模块联邦的方案。 NPM你有一个组件包通过npm发布后，你的10个业务项目引用这个组件包。当这个组件包更新了版本，你的10个项目想要使用最新功能就必须一一升级版本、编译打包、部署，这很繁琐。但是模块联邦让组件包利用CDN的方式共享给其他项目，这样一来，当你到组件包更新了，你的10个项目中的组件也自然更新了。是不是很香(^▽^)维护一个 CommonComponents 的 NPM 包，在不同项目中安装、使用。如果 NPM 包升级，对应项目都需要安装新版本，本地编译，打包到 bundle 中。UMD即Universal Module Definition（通用模块规范），基本原理是利用设计模式中的工厂函数来统一不同的模块定义规范。类似于我们开发的时候，经常会把某些功能封装成可复用的模块。并且对外暴露一个API，比如jquery、lodash等这类第三方插件，也可以通过CND的方式直接应用。后续这个公共函数的升级改造，我们更新CND引用链接地址，应用就自然也更新了。UMD 优点在 runtime。缺点也明显，体积优化不方便，容易有版本冲突。 微前端独立应用间的共享也是问题。一般有两种打包方式： 子应用独立打包，模块解耦了，但公共的依赖不易维护处理 整体应用一起打包，能解决公共依赖；但庞大的多个项目又使打包变慢，后续也不好扩展插拔式的热更新 从图中可以看到，这个方案是直接将一个应用的 bundle，应用于另一个应用。应用可以模块化输出，就是说它本身可以自我消费，也可以动态分发 runtime 子模块给其他应用 。试想一下，你有一个组件包通过npm发布后，你的10个业务项目引用这个组件包。当这个组件包更新了版本，你的10个项目想要使用最新功能就必须一一升级版本、编译打包、部署，这很繁琐。但是模块联邦让组件包利用CDN的方式共享给其他项目，这样一来，当你到组件包更新了，你的10个项目中的组件也自然更新了。是不是很香(^▽^) 大部分子应用都依赖的资源怎么处理模块联邦可以去依赖一个远程模块，这个依赖会在运行时生效，并不影响编译时。因此，这个远程依赖的模块就可以是一个微前端独立模块。同时，每个独立模块都可以申明公共的依赖库，这样也可以避免独立模块间的依赖包的冗余和冲突。在shared中可以定义依赖的公共库，这个例子就是rxjs。这样就可以保证整个应用仅仅会加载rxjs库一次，否则的话公共库会被打包进入宿主应用，同时也会在各个子模块中重复出现。 当然，shared的公共库需要保证是一样的版本。","categories":[{"name":"Webpack","slug":"Webpack","permalink":"https://nevvvver.github.io/categories/Webpack/"}],"tags":[{"name":"webpack5","slug":"webpack5","permalink":"https://nevvvver.github.io/tags/webpack5/"}]},{"title":"《深入浅出Node.js》笔记","slug":"深入浅出NodeJS","date":"2022-07-13T09:35:49.000Z","updated":"2022-10-11T02:58:57.985Z","comments":true,"path":"2022/07/13/深入浅出NodeJS/","link":"","permalink":"https://nevvvver.github.io/2022/07/13/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS/","excerpt":"","text":"第1章 Node简介电子书：《深入浅出Node.js》 1.1 Node的诞生历程1.2 Node的命名与起源 设计高性能Web服务器的几个要点：事件驱动、非阻塞I&#x2F;O。 1.3 Node给JavaScript带来的意义 Node打破了过去JavaScript只能在浏览器中运行的局面。 在Node中，JavaScript可以随心所欲地访问本地文件，可以搭建WebSocket服务端，可以连接数据库，可以如Web Workers一样玩转多进程。 1.4 Node的特点1.4.1 异步I&#x2F;O12345// 发起一个Ajax请求$.post(&#x27;/url&#x27;, &#123;title: &#x27;深入浅出Node.js&#x27;&#125;, function (data) &#123; console.log(&#x27;收到响应&#x27;); //将在异步请求结束后执行，但不知道具体的时间点&#125;);console.log(&#x27;发送Ajax结束&#x27;); “收到响应”是在“发送Ajax结束”之后输出的。 这里的“发起读取文件”是在“读取文件完成”之前输出的。 1234567// 读取文件var fs = require(&#x27;fs&#x27;);fs.readFile(&#x27;/path&#x27;,function(err,file)&#123; console.log(&#x27;读取文件完成&#x27;);&#125;);console.log(&#x27;发起读取文件&#x27;); 在Node中，绝大多数的操作都以异步的方式进行调用。每个调用之间无需等待之前的I&#x2F;O调用结束，在编程模型上可以极大提升效率。 对于异步而言，两个读取任务的耗时取决于最慢的那个文件读取的耗时。对于同步I&#x2F;O而言，它们的耗时是两个任务的耗时之和。 1.4.2 事件与回调函数 Node创建一个Web服务器，并监听8080端口。 对于服务器，我们为其绑定了request事件，对于请求对象，我们为其绑定了data事件和end事件。 1234567891011121314var http = require(&#x27;http&#x27;);var querystring = require(&#x27;querystring&#x27;);http.createServer(function(req, res)&#123; var postData = &#x27;&#x27;; req.setEncoding(&#x27;uft8&#x27;); req.on(&#x27;data&#x27;, function(trunk)&#123; postData += trunk; &#125;); req.on(&#x27;end&#x27;,function()&#123; res.end(postData); &#125;);&#125;).listen(8080);console.log(&#x27;服务器启动完成&#x27;); 相应地，我们在前端为Ajax请求定了success事件，在发出请求后，只需关心请求成功时执行相应的业务逻辑就即可。 12345678$.ajax(&#123; &#x27;url&#x27;: &#x27;/url&#x27;, &#x27;method&#x27;: &#x27;POST&#x27;, &#x27;data&#x27;: &#123;&#125;, &#x27;success&#x27;: function (data) &#123; // success事件 &#125;&#125;) Node除了异步和事件外，回调函数是一大特色。回调函数也是最好的接受异步调用返回数据的方式。 代码的编写顺序与执行顺序并无关系。 1.4.3 单线程 Node保持了JavaScript在浏览器中单线程的特点。而且在Node中，JavaScript与其余线程是无法共享任何状态的。 单线程的最大好处是不用像多线程编程那样在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换带来的性能上的开销。 单线程的弱点： 无法利用多核CPU； 错误会引起整个应用退出，应用的健壮性值得考验； 大量计算占用CPU导致无法继续调用异步I&#x2F;O。 Node采用了与Web Workers相同的思路来解决单线程中计算量的问题：子线程（child_process）。 1.4.4 跨平台 起初Node只可以在Linux平台上运行，现在Node可以借助libuv实现跨平台 1.5 Node的应用场景1.5.1 I&#x2F;O密集型 从单线程的角度来说，Node面向网络且擅长并行I&#x2F;O，能有效地组织起更多的硬件资源，从而提供更好的服务。 I&#x2F;O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。 1.5.2 是否不擅长CPU密集型业务 Node在性能上并不差，甚至表现得很优秀。 CPU密集的挑战主要是由于JavaScript单线程的原因，若有长时间运行的计算（大循环）将会导致CPU时间片不能释放，使得后续I&#x2F;O无法发起。但适当调整和分解大型运算任务为多个小任务，能使运算适时释放，不阻塞I&#x2F;O调用。 Node可以通过编写C&#x2F;C++扩展的方式更高效低利用CPU；利用子进程，将计算和I&#x2F;O分离。 1.5.3 与遗留系统和平共处1.5.4 分布式应用 阿里巴巴ࣄ开发了中间应用NodeFox、ITier，数据库及做了Ѳ分֖௡࠰,ಉលុ用Ιே是᧪对ӬषᛪᤈᛠSQLಉល，中ᫍࡎ分解ಉលSQL，并ᛠڠԜ多Ի数૵ं中ᖌԨ数૵并Ջ并。NodeFox能实ဗ对多ԻMySQL数૵ं的ಉល，ݟՎಉល一ԻMySQL一样，ᏪITierఝ强大，ಉល多个数૵ंݟՎ 1.6 Node的使用者 第2章 模块机制2.1 CommonJS规范2.1.1 CommonJS的出发点 在JavaScript的发展历程中，它主要在浏览器前端发光发热。官方规范（ECMAScript）规范化的时间较早，在实际应用中，JavaScript的表现能力取决于宿主环境中（浏览器）API支持程度。 后端JavaScript的规范远远落后，它的规范依然是薄弱的。 没有模块系统。 标准库较少。ES仅定义了部分核心库，对于文件系统I&#x2F;O流等常见需求却没有标准的API。 没有标准接口。 缺乏包管理系统。 2.1.2 CommonJS的模块规范1 模块引用 上下文提供require()方法来引入外部模块。 1var math = require(&#x27;math&#x27;); 2 模块定义 上下文提供export对象用于导出当前模块的方法或者变量，并且它事唯一导出的出口。 在模块中，还存在一个module对象，它代表模块自身，而export是module的属性。 123456789101112131415//math.jsexports.add = function()&#123; var sum = 0, i = 0, args = arguments, l = args.length; while(i &lt; l)&#123; sum += args[i++]; &#125; return sum; &#125;// program.jsvar math = require(&#x27;math&#x27;);console.log(math.add(1,2)) // 3 3 模块标识 模块标识其实就是传递给require()方法的参数，他必须是符合小驼峰命名的字符串，或者以.、..开ܿ的相对路径，或者绝对路径。每个模块具有独立的空间，互不干扰。 2.2 Node的模块实现 Node的模块机制只需要exports、require、module，但在Node中引入模块需要经历3个步骤： （1）路径分析 （2）文件定位 （3）编译执行 Node的两类模块： 核心模块（Node提供的模块）： 在Node源代码的编译过程中，编译进了二进制执行文件。在node进程启动时，部分核心模块就直接加载进内存中，所以这部分核心模块引入时，无需文件定位和编译执行，并且在路径分析中优先判断，所以它的加载速度是最快的。 文件模块（用户编写的模块）：在运行时动态加载，需要完整的三个步骤，速度比核心模块慢。 2.2.1 优先从缓存加载 Node对引入过的模块都会进行缓存，减少二次引入时的开销。 不同的地方在于，浏览器仅仅缓存文件，而Node缓存的是编译之后的对象。 核心模块的缓存检查优先于文件模块的缓存检查。 2.2.2 路径分析和文件定位1 路径分析（模块标识符分析） 对于不同的标识符，模块的查找和定位有不同程度上的差异。 模块标识符分为4类： 核心模块，如http、fs、path等。 .或..开始的相对路径文件模块。 /开始的绝对路径文件模块。 非路径形式的文件模块，如自定义的connect模块。 核心模块：核心模块的优先级仅次于缓存加载，已在Node源码编译过程编译成二进制代码，其加载过程最快。如果试图加载一个与核心模块标识符相同的自定模块，必须选择一个不同的标识符或换用路径的方式。 路径形式的文件模块：以.、..、/开始的标识符，都被当作文件模块来处理。在分析路径模块时，require()会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果放到缓存中，以便二次加载。也可以节约大量时间，因为给Node指明了确切的文件位置。 自定义模块：这类模块查找是最费时的。 模块路径：是Node在定位文件模块的具体文件时制定的查找策略，是一个路径组成的数组。可以看出，模块路径的生成规则是，原路径向上逐级递归，直到根目录下的node_modules目录。若当前文件路径越深，模块查找耗时会越多。 12345678910111213//module_path.jsconsole.log(module.paths)//以下是在MacOS下vscode的输出[ &#x27;/Users/Never/Desktop/project/nodeStudy/path/node_modules&#x27;, &#x27;/Users/Never/Desktop/project/nodeStudy/node_modules&#x27;, &#x27;/Users/Never/Desktop/project/node_modules&#x27;, &#x27;/Users/Never/Desktop/node_modules&#x27;, &#x27;/Users/Never/node_modules&#x27;, &#x27;/Users/node_modules&#x27;, &#x27;/node_modules&#x27;] 12345678910// 当前目录: /usr/local/test/index.js// gulp模块所在路径为 /usr/lib/node_modulesconsole.log(module.paths); // [&#x27;/usr/local/test/node_modules&#x27;, &#x27;/usr/local/node_modules&#x27;, &#x27;/usr/node_modules&#x27;, &#x27;/node_modules&#x27;]var gulp = require(&#x27;gulp&#x27;); // 报错“MODULE_NOT_FOUND”// 尝试修改该数组 影响本模块加载依赖的顺序module.paths.push(&#x27;/usr/lib/node_modules&#x27;); console.log(module.paths); //[&#x27;/usr/local/test/node_modules&#x27;, &#x27;/usr/local/node_modules&#x27;, &#x27;/usr/node_modules&#x27;, &#x27;/node_modules&#x27;, &#x27;/usr/lib/node_modules&#x27;]var gulp = require(&#x27;gulp&#x27;); // 运行成功，但Node会在找到gulp依赖前遍历4层目录，最后才在第五层目录中找到它 2 文件定位 文件定位主要包括文件扩展名分析、目录和包的处理 文件扩展名分析 require()在分析不包含文件扩展名的标识符时，Node会按.js、.json、.node的次序补足扩展名，依次尝试。 Node需要调用fs模块同步阻塞式地判断文件是否存在。因此若.json、.node文件，给标识符带上扩展名会更快。 目录分析和包 分析文件扩展名之后，可能没有找到对应文件，但却找到一个目录，Node则会将目录当作一个包来处理。 Node在当前目录下查找package.json，通过JSON.parse()解析出包描述的对象，从中找到main属性置顶的文件名进行定位，若缺少扩展名则会进行扩展名分析的不走。若main指定的文件错误或根本没有package.json，Node则会将index当作默认文件名，一次查找index.js、index.jsn、index.node。 若在目录分析中没有定位成功任何文件，则进入下一个模块路径进行查找，知道路径数组都被遍历完毕，还是没找到目标文件，就会抛出查找失败的异常。 2.2.3 模块编译 每个文件模块都是一个对象，定义如下：1234567891011function Module(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; if(parent &amp;&amp; parent.children) &#123; parent.children.push(this); &#125; this.filename = null; this.loaded = false; this.children = [];&#125; 编译和执行是引入模块的最后一个阶段。 第3章 异步I&#x2F;O3.13.3 Node的异步I&#x2F;O3.3.1 事件循环 Node自身的执行模型——事件循环。","categories":[{"name":"Books","slug":"Books","permalink":"https://nevvvver.github.io/categories/Books/"}],"tags":[{"name":"node","slug":"node","permalink":"https://nevvvver.github.io/tags/node/"}]},{"title":"《JavaScript权威指南(第6版)》笔记","slug":"JavaScript权威指南","date":"2022-07-11T09:27:54.000Z","updated":"2022-07-18T09:48:41.697Z","comments":true,"path":"2022/07/11/JavaScript权威指南/","link":"","permalink":"https://nevvvver.github.io/2022/07/11/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/","excerpt":"","text":"第〇部分第1章 JavaScript概述电子书：《JavaScript权威指南(第6版)》 第一部分 JavaScript 语言核心第2章 词法结构2.1 字符集第6章 对象 内置对象（native object）是由ECMAScript规范定义的对象或类。例如数组、函数、日期、正则表达式等。 宿主对象（host object）是由JavaScript解释器所嵌入的宿主环境（比如Web浏览器）定义的。 自定义对象 （user-defiend object）是由运行中的JavaScript代码创建的对象。 自有属性（own property）是直接在对象中定义的属性。 继承属性（inherited property）是在对象的原型对象中定义的属性。 6.1 创建对象对象直接量 1234567891011var empty = &#123;&#125;;var point = &#123; x:0, y:0 &#125;;var book = &#123; &quot;main title&quot;: &quot;JavaScript&quot;, &quot;sub-title&quot;: &quot;The Definitive Guide&quot;, &quot;for&quot;: &quot;all audiences&quot;, author: &#123; firstname: &quot;David&quot;, surname: &quot;Flanagan&quot; &#125;&#125; 对象直接量是一个表达式，表达式的每次运算都创建并初始化一个新的对象。 关键字new 1234var o = new Object(); // 创建一个空对象，和&#123;&#125;一样var a = new Array(); // 创建一个空数组，和[]一样var d = new Date(); // 创建一个白哦是当前时间的Date对象var r = new RegExp(&quot;js&quot;); // 创建一个可以进行模式匹配的RegExp对象 new运算符后面跟的是一个函数调用，这个函数被称为构造函数（constructor）。js中原始类型都包含内置的构造函数，也可以自己定义构造函数。 原型 每一个JavaScript对象（null除外）对合另一个对象（原型）相关联，每一个对象都从原型继承属性。 通过new Object()创建的对象也继承自Object.prototype，new Array() Object.create()（ES5） 第9章 类和模块9.1 类和原型 类的所有实例对象都从同一个原型对象上继承属性。 12345// range.js: 实现一个能表示值的范围的类// 这个工厂方法返回一个新的“范围对象”function range(from, to) &#123;&#125; 9.2 类和构造函数1234var F = function()&#123;&#125;; // 这是一个函数对象var p = F.prototype; // 这是F相关联的原型对象var c = p.constructor; // 这是与原型相关联的函数c === F // =&gt; true 12var o = new F(); // 创建类F的一个实例o.constructor === F // =&gt; true construtor属性指代这个类 对于任意函数 F.prototype.constructor === F 9.3 JavaScript中Java式的类继承 类字段、类方法；实例字段、实例方法 构造函数对象原型对象 9.5 类和类型 三种可以检测对象的类的方法：instanceof运算符、constructor属性、构造函数的名字。 三种方法都不完美，但利用鸭式辩型，可以更加关注对象可以完成什么工做而不是对象属于哪个类。 instanceof运算符 o instanceof c 返回true，表示o继承自c.prototype，这里的继承可以不是直接继承 构造函数是类的公共标识，但原型是唯一的标识。instanceof检测了对象的继承关系，而不是检测创建对象的构造函数 constructor属性-","categories":[{"name":"Books","slug":"Books","permalink":"https://nevvvver.github.io/categories/Books/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://nevvvver.github.io/tags/javascript/"}]},{"title":"jsoneditor-react的类型声明文件","slug":"jsoneditor-react的类型声明文件","date":"2022-06-07T09:25:44.000Z","updated":"2022-06-07T09:46:02.848Z","comments":true,"path":"2022/06/07/jsoneditor-react的类型声明文件/","link":"","permalink":"https://nevvvver.github.io/2022/06/07/jsoneditor-react%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6/","excerpt":"","text":"jsoneditor-react.d.ts放在src下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475declare module &#x27;jsoneditor-react&#x27; &#123; export class JsonEditor extends React.Component&lt;JsonEditorProps&gt; &#123; public jsonEditor: unknown; &#125; type Mode = &#x27;tree&#x27; | &#x27;view&#x27; | &#x27;form&#x27; | &#x27;code&#x27; | &#x27;text&#x27;; interface JsonEditorProps &#123; value: unknown; /** Set the editor mode. Default &#x27;tree&#x27; */ mode?: Mode; /** Initial field name for root node */ name?: string; /** Validate the JSON object against a JSON schema. */ schema: unknown; /** Schemas that are referenced using the $ref property */ schemaRefs?: object; /** * If true, object keys in &#x27;tree&#x27;, &#x27;view&#x27; or &#x27;form&#x27; mode list be listed alphabetically * instead by their insertion order. * */ sortObjectKeys?: boolean; /** Set a callback function triggered when json in the JSONEditor change */ onChange?: (value: object[]) =&gt; void; /** * Set a callback function triggered when an error occurs. * Invoked with the error as first argument. * The callback is only invoked for errors triggered by a users action, * like switching from code mode to tree mode or clicking * the Format button whilst the editor doesn&#x27;t contain valid JSON. */ onError?: (error: unknown) =&gt; void; /** Set a callback function triggered right after the mode is changed by the user. */ onModeChange?: (mode: Mode) =&gt; void; onClassName?: (args: &#123; path: unknown; field: unknown; value: unknown &#125;) =&gt; void; /** Provide a version of the Ace editor. Only applicable when mode is code */ ace?: object; /** Provide a instance of ajv,the library used for JSON schema validation. */ ajv?: object; /** Set the Ace editor theme, uses included &#x27;ace/theme/jsoneditor&#x27; by default. */ theme?: string; /** * Enables history, adds a button Undo and Redo to the menu of the JSONEditor. * Only applicable when mode is &#x27;tree&#x27; or &#x27;form&#x27;. Default to false */ history?: boolean; /** * Adds navigation bar to the menu * the navigation bar visualize the current position on the * tree structure as well as allows breadcrumbs navigation. Default to true */ navigationBar?: boolean; /** * Adds status bar to the buttom of the editor * the status bar shows the cursor position and a count of the selected characters. * Only applicable when mode is &#x27;code&#x27; or &#x27;text&#x27;. Default to true */ statusBar?: boolean; /** Enables a search box in the upper right corner of the JSONEditor. Default to true */ search?: boolean; /** Create a box in the editor menu where the user can switch between the specified modes. */ allowedModes?: Mode[]; /** Html element, or react element to render */ tag?: string | HTMLElement; /** html element custom props */ htmlElementProps?: object; /** callback to get html element reference */ innerRef?: (ref: unknown) =&gt; void; &#125;&#125;","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://nevvvver.github.io/categories/TypeScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://nevvvver.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://nevvvver.github.io/tags/es6/"}]},{"title":"可枚举性(enumerable)","slug":"enumerable","date":"2022-03-14T18:53:58.000Z","updated":"2022-03-15T16:09:02.657Z","comments":true,"path":"2022/03/15/enumerable/","link":"","permalink":"https://nevvvver.github.io/2022/03/15/enumerable/","excerpt":"","text":"描述 在 JavaScript 中，对象的属性可以分为实例属性和原型 (prototype) 属性。 实例属性：指的是自身属性。 原型属性：指的是从原型链上继承的属性。 Object.prototype.hasOwnProperty() 可以判断某一个属性是否是对象的自身属性。 对象的每一个属性都有一个描述对象 (Descriptor) ,描述对象的 enumerable 属性称为“可枚举性”。 引入“可枚举性”这个概念的最初目的，就是让某些属性可以规避掉 for...in 操作。 可枚举性的作用与可枚举性有关的操作： 函数方法 描述 实例属性 原型属性 for...in 遍历对象自身和原型上的所有可枚举属性 〇 〇 Object.keys() 返回对象自身的所有可枚举属性的键名 〇 JSON.stringify 只串行化对象自身的所有可枚举属性 〇 Object.assign()(ES6) 只拷贝对象自身的所有可枚举属性 〇 Object.getOwnPropertyNames() 返回对象自身的所有属性的键名 〇 code samples123456789101112131415function Person() &#123; this.name = &quot;Never&quot;;&#125;;// 通过直接的赋值和属性初始化的属性，可枚举性默认为truePerson.prototype.School = &#x27;Tust&#x27;;let person = new Person();// 通过 Object.defineProperty() 等定义的属性，可枚举性默认为falseObject.defineProperty(person, &quot;sex&quot;, &#123; value: &quot;male&quot;, // enumerable: false&#125;); 12345678910111213Object.keys(person).forEach(function(key) &#123; console.log(key) // name&#125;);for(var p in person)&#123; console.log(p); // name, School&#125;Object.getOwnPropertyNames(person).forEach(function(key) &#123; console.log(key)// name, sex&#125;); 如何判断属性是否可枚举 Object.propertyIsEnumerable() 方法可以判断一个属性是否是对象的可枚举的自身属性。（注：如果判断的属性是原型属性，不管它是否可枚举都会返回false） 123person.propertyIsEnumerable(&#x27;name&#x27;); // trueperson.propertyIsEnumerable(&#x27;School&#x27;); // falseperson.propertyIsEnumerable(&#x27;sex&#x27;); // false","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://nevvvver.github.io/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://nevvvver.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://nevvvver.github.io/tags/es6/"}]}],"categories":[{"name":"Webpack","slug":"Webpack","permalink":"https://nevvvver.github.io/categories/Webpack/"},{"name":"Books","slug":"Books","permalink":"https://nevvvver.github.io/categories/Books/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://nevvvver.github.io/categories/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://nevvvver.github.io/categories/JavaScript/"}],"tags":[{"name":"webpack5","slug":"webpack5","permalink":"https://nevvvver.github.io/tags/webpack5/"},{"name":"node","slug":"node","permalink":"https://nevvvver.github.io/tags/node/"},{"name":"javascript","slug":"javascript","permalink":"https://nevvvver.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://nevvvver.github.io/tags/es6/"}]}