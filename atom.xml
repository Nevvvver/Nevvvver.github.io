<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Never</title>
  
  
  <link href="https://nevvvver.github.io/atom.xml" rel="self"/>
  
  <link href="https://nevvvver.github.io/"/>
  <updated>2022-07-15T11:33:02.043Z</updated>
  <id>https://nevvvver.github.io/</id>
  
  <author>
    <name>Never</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《深入浅出Node.js》笔记</title>
    <link href="https://nevvvver.github.io/2022/07/13/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS/"/>
    <id>https://nevvvver.github.io/2022/07/13/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS/</id>
    <published>2022-07-13T09:35:49.000Z</published>
    <updated>2022-07-15T11:33:02.043Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第1章-Node简介"><a href="#第1章-Node简介" class="headerlink" title="第1章 Node简介"></a>第1章 Node简介</h3><p>电子书：<a href="https://awesome-programming-books.github.io/nodejs/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js.pdf">《深入浅出Node.js》</a></p><h4 id="1-1-Node的诞生历程"><a href="#1-1-Node的诞生历程" class="headerlink" title="1.1 Node的诞生历程"></a>1.1 Node的诞生历程</h4><h4 id="1-2-Node的命名与起源"><a href="#1-2-Node的命名与起源" class="headerlink" title="1.2 Node的命名与起源"></a>1.2 Node的命名与起源</h4><ul><li>设计高性能Web服务器的几个要点：事件驱动、非阻塞I&#x2F;O。</li></ul><h4 id="1-3-Node给JavaScript带来的意义"><a href="#1-3-Node给JavaScript带来的意义" class="headerlink" title="1.3 Node给JavaScript带来的意义"></a>1.3 Node给JavaScript带来的意义</h4><ul><li>Node打破了过去JavaScript只能在浏览器中运行的局面。</li><li>在Node中，JavaScript可以随心所欲地访问本地文件，可以搭建WebSocket服务端，可以连接数据库，可以如Web Workers一样玩转多进程。</li></ul><p><img src="/2022/07/13/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS/1-1.png"></p><h4 id="1-4-Node的特点"><a href="#1-4-Node的特点" class="headerlink" title="1.4 Node的特点"></a>1.4 Node的特点</h4><h5 id="1-4-1-异步I-x2F-O"><a href="#1-4-1-异步I-x2F-O" class="headerlink" title="1.4.1 异步I&#x2F;O"></a>1.4.1 异步I&#x2F;O</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起一个Ajax请求</span></span><br><span class="line">$.<span class="title function_">post</span>(<span class="string">&#x27;/url&#x27;</span>, &#123;<span class="attr">title</span>: <span class="string">&#x27;深入浅出Node.js&#x27;</span>&#125;, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到响应&#x27;</span>); <span class="comment">//将在异步请求结束后执行，但不知道具体的时间点</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发送Ajax结束&#x27;</span>); </span><br></pre></td></tr></table></figure><ul><li>“收到响应”是在“发送Ajax结束”之后输出的。</li></ul><p><img src="/2022/07/13/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS/1-2.png?450x" alt="经典的Ajax调用"></p><ul><li>这里的“发起读取文件”是在“读取文件完成”之前输出的。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/path&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,file</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取文件完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发起读取文件&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>在Node中，绝大多数的操作都以异步的方式进行调用。</strong>每个调用之间无需等待之前的I&#x2F;O调用结束，在编程模型上可以极大提升效率。</li><li>对于异步而言，两个读取任务的耗时取决于最慢的那个文件读取的耗时。对于同步I&#x2F;O而言，它们的耗时是两个任务的耗时之和。</li></ul><h5 id="1-4-2-事件与回调函数"><a href="#1-4-2-事件与回调函数" class="headerlink" title="1.4.2 事件与回调函数"></a>1.4.2 事件与回调函数</h5><ul><li>Node创建一个Web服务器，并监听8080端口。</li><li>对于服务器，我们为其绑定了request事件，对于请求对象，我们为其绑定了data事件和end事件。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> postData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  req.<span class="title function_">setEncoding</span>(<span class="string">&#x27;uft8&#x27;</span>);</span><br><span class="line">  req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">trunk</span>)&#123;</span><br><span class="line">    postData += trunk;</span><br><span class="line">  &#125;);</span><br><span class="line">  req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    res.<span class="title function_">end</span>(postData);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务器启动完成&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>相应地，我们在前端为Ajax请求定了success事件，在发出请求后，只需关心请求成功时执行相应的业务逻辑就即可。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line"> <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;/url&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;data&#x27;</span>: &#123;&#125;,</span><br><span class="line"> <span class="string">&#x27;success&#x27;</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line"> <span class="comment">// success事件</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>Node除了异步和事件外，回调函数是一大特色。回调函数也是最好的接受异步调用返回数据的方式。</li><li>代码的编写顺序与执行顺序并无关系。</li></ul><h5 id="1-4-3-单线程"><a href="#1-4-3-单线程" class="headerlink" title="1.4.3 单线程"></a>1.4.3 单线程</h5><ul><li>Node保持了JavaScript在浏览器中单线程的特点。而且在Node中，JavaScript与其余线程是无法共享任何状态的。</li><li>单线程的最大好处是不用像多线程编程那样在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换带来的性能上的开销。</li><li>单线程的弱点：<ul><li>无法利用多核CPU；</li><li>错误会引起整个应用退出，应用的健壮性值得考验；</li><li>大量计算占用CPU导致无法继续调用异步I&#x2F;O。</li></ul></li><li>Node采用了与Web Workers相同的思路来解决单线程中计算量的问题：<strong>子线程（child_process）</strong>。</li></ul><h5 id="1-4-4-跨平台"><a href="#1-4-4-跨平台" class="headerlink" title="1.4.4 跨平台"></a>1.4.4 跨平台</h5><ul><li>起初Node只可以在Linux平台上运行，现在Node可以借助libuv实现跨平台<br><img src="/2022/07/13/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS/1-3.png?350x"></li></ul><h4 id="1-5-Node的应用场景"><a href="#1-5-Node的应用场景" class="headerlink" title="1.5 Node的应用场景"></a>1.5 Node的应用场景</h4><h5 id="1-5-1-I-x2F-O密集型"><a href="#1-5-1-I-x2F-O密集型" class="headerlink" title="1.5.1 I&#x2F;O密集型"></a>1.5.1 I&#x2F;O密集型</h5><ul><li>从单线程的角度来说，Node面向网络且<strong>擅长并行I&#x2F;O</strong>，能有效地组织起更多的硬件资源，从而提供更好的服务。</li><li>I&#x2F;O密集的优势主要在于Node利用<strong>事件循环</strong>的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。</li></ul><h5 id="1-5-2-是否不擅长CPU密集型业务"><a href="#1-5-2-是否不擅长CPU密集型业务" class="headerlink" title="1.5.2 是否不擅长CPU密集型业务"></a>1.5.2 是否不擅长CPU密集型业务</h5><ul><li>Node在性能上并不差，甚至表现得很优秀。</li><li>CPU密集的挑战主要是由于JavaScript单线程的原因，若有长时间运行的计算（大循环）将会导致CPU时间片不能释放，使得后续I&#x2F;O无法发起。但适当调整和分解大型运算任务为多个小任务，能使运算适时释放，不阻塞I&#x2F;O调用。</li><li>Node可以通过编写C&#x2F;C++扩展的方式更高效低利用CPU；利用子进程，将计算和I&#x2F;O分离。</li></ul><h5 id="1-5-3-与遗留系统和平共处"><a href="#1-5-3-与遗留系统和平共处" class="headerlink" title="1.5.3 与遗留系统和平共处"></a>1.5.3 与遗留系统和平共处</h5><h5 id="1-5-4-分布式应用"><a href="#1-5-4-分布式应用" class="headerlink" title="1.5.4 分布式应用"></a>1.5.4 分布式应用</h5><ul><li>阿里巴巴ࣄ开发了中间应用NodeFox、ITier，数据库及做了Ѳ分֖௡࠰,ಉលុ用Ιே是᧪对ӬषᛪᤈᛠSQLಉ<br>ល，中ᫍࡎ分解ಉលSQL，并ᛠڠԜ多Ի数૵ं中ᖌԨ数૵并Ջ并。NodeFox能实ဗ对多ԻMySQL<br>数૵ं的ಉល，ݟՎಉល一ԻMySQL一样，ᏪITierఝ强大，ಉល多个数૵ंݟՎ</li></ul><h4 id="1-6-Node的使用者"><a href="#1-6-Node的使用者" class="headerlink" title="1.6 Node的使用者"></a>1.6 Node的使用者</h4><hr><h3 id="第2章-模块机制"><a href="#第2章-模块机制" class="headerlink" title="第2章 模块机制"></a>第2章 模块机制</h3><h4 id="2-1-CommonJS规范"><a href="#2-1-CommonJS规范" class="headerlink" title="2.1 CommonJS规范"></a>2.1 CommonJS规范</h4><h5 id="2-1-1-CommonJS的出发点"><a href="#2-1-1-CommonJS的出发点" class="headerlink" title="2.1.1 CommonJS的出发点"></a>2.1.1 CommonJS的出发点</h5><ul><li>在JavaScript的发展历程中，它主要在浏览器前端发光发热。官方规范（ECMAScript）规范化的时间较早，在实际应用中，JavaScript的表现能力取决于宿主环境中（浏览器）API支持程度。</li><li>后端JavaScript的规范远远落后，它的规范依然是薄弱的。<ul><li>没有模块系统。</li><li>标准库较少。ES仅定义了部分核心库，对于文件系统I&#x2F;O流等常见需求却没有标准的API。</li><li>没有标准接口。</li><li>缺乏包管理系统。</li></ul></li></ul><h5 id="2-1-2-CommonJS的模块规范"><a href="#2-1-2-CommonJS的模块规范" class="headerlink" title="2.1.2 CommonJS的模块规范"></a>2.1.2 CommonJS的模块规范</h5><p><strong>1 模块引用</strong></p><ul><li>上下文提供<code>require()</code>方法来引入外部模块。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>2 模块定义</strong></p><ul><li>上下文提供<code>export</code>对象用于导出当前模块的方法或者变量，并且它事唯一导出的出口。</li><li>在模块中，还存在一个<code>module</code>对象，它代表模块自身，而<code>export</code>是<code>module</code>的属性。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//math.js</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>,</span><br><span class="line">      i = <span class="number">0</span>,</span><br><span class="line">      args = <span class="variable language_">arguments</span>,</span><br><span class="line">      l = args.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; l)&#123;</span><br><span class="line">      sum += args[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// program.js</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><strong>3 模块标识</strong></p><ul><li>模块标识其实就是传递给<code>require()</code>方法的参数，他必须是符合<strong>小驼峰命名</strong>的字符串，或者以.、..开ܿ的相对路径，或者绝对路径。每个模块具有独立的空间，互不干扰。</li></ul><p><img src="/2022/07/13/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS/2-1.png?x444"></p><h4 id="2-2-Node的模块实现"><a href="#2-2-Node的模块实现" class="headerlink" title="2.2 Node的模块实现"></a>2.2 Node的模块实现</h4><ul><li>Node的模块机制只需要<code>exports</code>、<code>require</code>、<code>module</code>，但在Node中引入模块需要经历3个步骤：<ul><li>（1）路径分析</li><li>（2）文件定位</li><li>（3）编译执行</li></ul></li><li>Node的两类模块：<ul><li><strong>核心模块（Node提供的模块）</strong>： 在Node源代码的编译过程中，编译进了二进制执行文件。在node进程启动时，部分核心模块就直接加载进内存中，所以这部分核心模块引入时，无需文件定位和编译执行，并且在路径分析中优先判断，所以它的加载速度是最快的。</li><li><strong>文件模块（用户编写的模块）</strong>：在运行时动态加载，需要完整的三个步骤，速度比核心模块慢。</li></ul></li></ul><h5 id="2-2-1-优先从缓存加载"><a href="#2-2-1-优先从缓存加载" class="headerlink" title="2.2.1 优先从缓存加载"></a>2.2.1 优先从缓存加载</h5><ul><li>Node对引入过的模块都会进行缓存，减少二次引入时的开销。</li><li>不同的地方在于，浏览器仅仅缓存文件，而Node缓存的是编译之后的对象。</li><li>核心模块的缓存检查优先于文件模块的缓存检查。</li></ul><h5 id="2-2-2-路径分析和文件定位"><a href="#2-2-2-路径分析和文件定位" class="headerlink" title="2.2.2 路径分析和文件定位"></a>2.2.2 路径分析和文件定位</h5><p><strong>1 路径分析（模块标识符分析）</strong></p><ul><li><p>对于不同的标识符，模块的查找和定位有不同程度上的差异。</p></li><li><p>模块标识符分为4类：</p><ul><li>核心模块，如<code>http</code>、<code>fs</code>、<code>path</code>等。</li><li><code>.</code>或<code>..</code>开始的相对路径文件模块。</li><li><code>/</code>开始的绝对路径文件模块。</li><li>非路径形式的文件模块，如自定义的<code>connect</code>模块。</li></ul></li><li><p><strong>核心模块：</strong>核心模块的优先级仅次于缓存加载，已在Node源码编译过程编译成二进制代码，其加载过程最快。如果试图加载一个与核心模块标识符相同的自定模块，必须选择一个不同的标识符或换用路径的方式。</p></li><li><p><strong>路径形式的文件模块：</strong>以<code>.</code>、<code>..</code>、<code>/</code>开始的标识符，都被当作文件模块来处理。在分析路径模块时，<code>require()</code>会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果放到缓存中，以便二次加载。也可以节约大量时间，因为给Node指明了确切的文件位置。</p></li><li><p><strong>自定义模块：</strong>这类模块查找是最费时的。</p><blockquote><p><strong>模块路径：</strong>是Node在定位文件模块的具体文件时制定的查找策略，是一个路径组成的数组。可以看出，模块路径的生成规则是，原路径向上逐级递归，直到根目录下的node_modules目录。若当前文件路径越深，模块查找耗时会越多。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_path.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">module</span>.<span class="property">paths</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是在MacOS下vscode的输出</span></span><br><span class="line">[</span><br><span class="line">  <span class="string">&#x27;/Users/Never/Desktop/project/nodeStudy/path/node_modules&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/Users/Never/Desktop/project/nodeStudy/node_modules&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/Users/Never/Desktop/project/node_modules&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/Users/Never/Desktop/node_modules&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/Users/Never/node_modules&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/Users/node_modules&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/node_modules&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前目录: /usr/local/test/index.js</span></span><br><span class="line"><span class="comment">// gulp模块所在路径为 /usr/lib/node_modules</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">module</span>.<span class="property">paths</span>);    <span class="comment">// [&#x27;/usr/local/test/node_modules&#x27;, &#x27;/usr/local/node_modules&#x27;, &#x27;/usr/node_modules&#x27;, &#x27;/node_modules&#x27;]</span></span><br><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);   <span class="comment">// 报错“MODULE_NOT_FOUND”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试修改该数组 影响本模块加载依赖的顺序</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">paths</span>.<span class="title function_">push</span>(<span class="string">&#x27;/usr/lib/node_modules&#x27;</span>);   </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">module</span>.<span class="property">paths</span>);    <span class="comment">//[&#x27;/usr/local/test/node_modules&#x27;, &#x27;/usr/local/node_modules&#x27;, &#x27;/usr/node_modules&#x27;, &#x27;/node_modules&#x27;, &#x27;/usr/lib/node_modules&#x27;]</span></span><br><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);   <span class="comment">// 运行成功，但Node会在找到gulp依赖前遍历4层目录，最后才在第五层目录中找到它</span></span><br></pre></td></tr></table></figure><p><strong>2 文件定位</strong></p><ul><li>文件定位主要包括文件扩展名分析、目录和包的处理</li></ul><p><strong>文件扩展名分析</strong></p><ul><li><code>require()</code>在分析不包含文件扩展名的标识符时，Node会按<code>.js</code>、<code>.json</code>、<code>.node</code>的次序补足扩展名，依次尝试。</li><li>Node需要调用fs模块同步阻塞式地判断文件是否存在。因此若<code>.json</code>、<code>.node</code>文件，给标识符带上扩展名会更快。</li></ul><p><strong>目录分析和包</strong></p><ul><li>分析文件扩展名之后，可能没有找到对应文件，但却找到一个目录，Node则会将目录当作一个包来处理。</li><li>Node在当前目录下查找<code>package.json</code>，通过<code>JSON.parse()</code>解析出包描述的对象，从中找到<code>main</code>属性置顶的文件名进行定位，若缺少扩展名则会进行扩展名分析的不走。若<code>main</code>指定的文件错误或根本没有<code>package.json</code>，Node则会将<code>index</code>当作默认文件名，一次查找<code>index.js</code>、<code>index.jsn</code>、<code>index.node</code>。</li><li>若在目录分析中没有定位成功任何文件，则进入下一个模块路径进行查找，知道路径数组都被遍历完毕，还是没找到目标文件，就会抛出查找失败的异常。</li></ul><h5 id="2-2-3-模块编译"><a href="#2-2-3-模块编译" class="headerlink" title="2.2.3 模块编译"></a>2.2.3 模块编译</h5><ul><li>每个文件模块都是一个对象，定义如下：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Module</span>(<span class="params">id, parent</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">id</span> = id;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">exports</span> = &#123;&#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">parent</span> = parent;</span><br><span class="line">  <span class="keyword">if</span>(parent &amp;&amp; parent.<span class="property">children</span>) &#123;</span><br><span class="line">    parent.<span class="property">children</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">filename</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">loaded</span> = <span class="literal">false</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">children</span> = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译和执行是引入模块的最后一个阶段。</li></ul><h3 id="第3章-异步I-x2F-O"><a href="#第3章-异步I-x2F-O" class="headerlink" title="第3章 异步I&#x2F;O"></a>第3章 异步I&#x2F;O</h3><h4 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h4><h4 id="3-3-Node的异步I-x2F-O"><a href="#3-3-Node的异步I-x2F-O" class="headerlink" title="3.3 Node的异步I&#x2F;O"></a>3.3 Node的异步I&#x2F;O</h4><h5 id="3-3-1-事件循环"><a href="#3-3-1-事件循环" class="headerlink" title="3.3.1 事件循环"></a>3.3.1 事件循环</h5><ul><li>Node自身的执行模型——事件循环。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第1章-Node简介&quot;&gt;&lt;a href=&quot;#第1章-Node简介&quot; class=&quot;headerlink&quot; title=&quot;第1章 Node简介&quot;&gt;&lt;/a&gt;第1章 Node简介&lt;/h3&gt;&lt;p&gt;电子书：&lt;a href=&quot;https://awesome-programmi</summary>
      
    
    
    
    <category term="Books" scheme="https://nevvvver.github.io/categories/Books/"/>
    
    
    <category term="node" scheme="https://nevvvver.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript权威指南(第6版)》笔记</title>
    <link href="https://nevvvver.github.io/2022/07/11/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    <id>https://nevvvver.github.io/2022/07/11/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</id>
    <published>2022-07-11T09:27:54.000Z</published>
    <updated>2022-07-18T09:48:41.697Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第〇部分"><a href="#第〇部分" class="headerlink" title="第〇部分"></a>第〇部分</h3><h4 id="第1章-JavaScript概述"><a href="#第1章-JavaScript概述" class="headerlink" title="第1章 JavaScript概述"></a>第1章 JavaScript概述</h4><p>电子书：<a href="https://awesome-programming-books.github.io/javascript/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97(%E7%AC%AC6%E7%89%88).pdf">《JavaScript权威指南(第6版)》</a></p><h3 id="第一部分-JavaScript-语言核心"><a href="#第一部分-JavaScript-语言核心" class="headerlink" title="第一部分 JavaScript 语言核心"></a>第一部分 JavaScript 语言核心</h3><h4 id="第2章-词法结构"><a href="#第2章-词法结构" class="headerlink" title="第2章 词法结构"></a>第2章 词法结构</h4><h5 id="2-1-字符集"><a href="#2-1-字符集" class="headerlink" title="2.1 字符集"></a>2.1 字符集</h5><h4 id="第6章-对象"><a href="#第6章-对象" class="headerlink" title="第6章 对象"></a>第6章 对象</h4><ul><li><strong>内置对象（native object）</strong>是由ECMAScript规范定义的对象或类。例如数组、函数、日期、正则表达式等。</li><li><strong>宿主对象（host object）</strong>是由JavaScript解释器所嵌入的宿主环境（比如Web浏览器）定义的。</li><li><strong>自定义对象 （user-defiend object）</strong>是由运行中的JavaScript代码创建的对象。</li><li><strong>自有属性（own property）</strong>是直接在对象中定义的属性。</li><li><strong>继承属性（inherited property）</strong>是在对象的原型对象中定义的属性。</li></ul><h5 id="6-1-创建对象"><a href="#6-1-创建对象" class="headerlink" title="6.1 创建对象"></a>6.1 创建对象</h5><p><strong>对象直接量</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> point = &#123; <span class="attr">x</span>:<span class="number">0</span>, <span class="attr">y</span>:<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  <span class="string">&quot;main title&quot;</span>: <span class="string">&quot;JavaScript&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sub-title&quot;</span>: <span class="string">&quot;The Definitive Guide&quot;</span>,</span><br><span class="line">  <span class="string">&quot;for&quot;</span>: <span class="string">&quot;all audiences&quot;</span>,</span><br><span class="line">  <span class="attr">author</span>: &#123;</span><br><span class="line">    <span class="attr">firstname</span>: <span class="string">&quot;David&quot;</span>,</span><br><span class="line">    <span class="attr">surname</span>: <span class="string">&quot;Flanagan&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对象直接量是一个表达式，表达式的每次运算都<strong>创建并初始化一个新的对象</strong>。</li></ul><hr><p><strong>关键字new</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();     <span class="comment">// 创建一个空对象，和&#123;&#125;一样</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Array</span>();      <span class="comment">// 创建一个空数组，和[]一样</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();       <span class="comment">// 创建一个白哦是当前时间的Date对象</span></span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;js&quot;</span>); <span class="comment">// 创建一个可以进行模式匹配的RegExp对象</span></span><br></pre></td></tr></table></figure><ul><li>new运算符后面跟的是一个<strong>函数调用</strong>，这个函数被称为<strong>构造函数（constructor）</strong>。js中原始类型都包含内置的构造函数，也可以自己定义构造函数。</li></ul><hr><p><strong>原型</strong></p><ul><li>每一个JavaScript对象（null除外）对合另一个对象（原型）相关联，每一个对象都从原型继承属性。</li><li>通过new Object()创建的对象也继承自<code>Object.prototype</code>，new Array()</li></ul><p><strong>Object.create()（ES5）</strong></p><h4 id="第9章-类和模块"><a href="#第9章-类和模块" class="headerlink" title="第9章 类和模块"></a>第9章 类和模块</h4><h5 id="9-1-类和原型"><a href="#9-1-类和原型" class="headerlink" title="9.1 类和原型"></a>9.1 类和原型</h5><ul><li>类的所有实例对象都从同一个原型对象上继承属性。</li><li></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range.js: 实现一个能表示值的范围的类</span></span><br><span class="line"><span class="comment">// 这个工厂方法返回一个新的“范围对象”</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">range</span>(<span class="params"><span class="keyword">from</span>, to</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="9-2-类和构造函数"><a href="#9-2-类和构造函数" class="headerlink" title="9.2 类和构造函数"></a>9.2 类和构造函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;   <span class="comment">// 这是一个函数对象</span></span><br><span class="line"><span class="keyword">var</span> p = F.<span class="property"><span class="keyword">prototype</span></span>;    <span class="comment">// 这是F相关联的原型对象</span></span><br><span class="line"><span class="keyword">var</span> c = p.<span class="property">constructor</span>;  <span class="comment">// 这是与原型相关联的函数</span></span><br><span class="line">c === F                 <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title function_">F</span>();        <span class="comment">// 创建类F的一个实例</span></span><br><span class="line">o.<span class="property">constructor</span> === F     <span class="comment">// =&gt; true construtor属性指代这个类</span></span><br></pre></td></tr></table></figure><ul><li>对于任意函数 <code>F.prototype.constructor === F</code></li></ul><p><img src="/2022/07/11/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/9-1.png"></p><h5 id="9-3-JavaScript中Java式的类继承"><a href="#9-3-JavaScript中Java式的类继承" class="headerlink" title="9.3 JavaScript中Java式的类继承"></a>9.3 JavaScript中Java式的类继承</h5><ul><li>类字段、类方法；实例字段、实例方法</li><li>构造函数对象<br>原型对象</li></ul><h5 id="9-5-类和类型"><a href="#9-5-类和类型" class="headerlink" title="9.5 类和类型"></a>9.5 类和类型</h5><ul><li>三种可以检测对象的类的方法：instanceof运算符、constructor属性、构造函数的名字。</li><li>三种方法都不完美，但利用鸭式辩型，可以更加关注对象可以完成什么工做而不是对象属于哪个类。</li></ul><h6 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h6><ul><li><code>o instanceof c</code> 返回true，表示o继承自c.prototype，这里的继承可以不是直接继承</li><li>构造函数是类的公共标识，但原型是唯一的标识。instanceof检测了对象的继承关系，而不是检测创建对象的构造函数</li></ul><h6 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h6><p>- </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第〇部分&quot;&gt;&lt;a href=&quot;#第〇部分&quot; class=&quot;headerlink&quot; title=&quot;第〇部分&quot;&gt;&lt;/a&gt;第〇部分&lt;/h3&gt;&lt;h4 id=&quot;第1章-JavaScript概述&quot;&gt;&lt;a href=&quot;#第1章-JavaScript概述&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Books" scheme="https://nevvvver.github.io/categories/Books/"/>
    
    
    <category term="javascript" scheme="https://nevvvver.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>jsoneditor-react的类型声明文件</title>
    <link href="https://nevvvver.github.io/2022/06/07/jsoneditor-react%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6/"/>
    <id>https://nevvvver.github.io/2022/06/07/jsoneditor-react%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6/</id>
    <published>2022-06-07T09:25:44.000Z</published>
    <updated>2022-06-07T09:46:02.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="jsoneditor-react-d-ts"><a href="#jsoneditor-react-d-ts" class="headerlink" title="jsoneditor-react.d.ts"></a>jsoneditor-react.d.ts</h3><p>放在src下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;jsoneditor-react&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">JsonEditor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&lt;<span class="title class_">JsonEditorProps</span>&gt; &#123;</span><br><span class="line">    public <span class="attr">jsonEditor</span>: unknown;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    type <span class="title class_">Mode</span> = <span class="string">&#x27;tree&#x27;</span> | <span class="string">&#x27;view&#x27;</span> | <span class="string">&#x27;form&#x27;</span> | <span class="string">&#x27;code&#x27;</span> | <span class="string">&#x27;text&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    interface <span class="title class_">JsonEditorProps</span> &#123;</span><br><span class="line">      <span class="attr">value</span>: unknown;</span><br><span class="line">      <span class="comment">/** Set the editor mode. Default &#x27;tree&#x27; */</span></span><br><span class="line">      mode?: <span class="title class_">Mode</span>;</span><br><span class="line">      <span class="comment">/** Initial field name for root node */</span></span><br><span class="line">      name?: string;</span><br><span class="line">      <span class="comment">/** Validate the JSON object against a JSON schema. */</span></span><br><span class="line">      <span class="attr">schema</span>: unknown;</span><br><span class="line">      <span class="comment">/** Schemas that are referenced using the $ref property */</span></span><br><span class="line">      schemaRefs?: object;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * If true, object keys in &#x27;tree&#x27;, &#x27;view&#x27; or &#x27;form&#x27; mode list be listed alphabetically</span></span><br><span class="line"><span class="comment">       * instead by their insertion order.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      sortObjectKeys?: boolean;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** Set a callback function triggered when json in the JSONEditor change */</span></span><br><span class="line">      onChange?: <span class="function">(<span class="params">value: object[]</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Set a callback function triggered when an error occurs.</span></span><br><span class="line"><span class="comment">       * Invoked with the error as first argument.</span></span><br><span class="line"><span class="comment">       * The callback is only invoked for errors triggered by a users action,</span></span><br><span class="line"><span class="comment">       * like switching from code mode to tree mode or clicking</span></span><br><span class="line"><span class="comment">       * the Format button whilst the editor doesn&#x27;t contain valid JSON.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      onError?: <span class="function">(<span class="params">error: unknown</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">      <span class="comment">/** Set a callback function triggered right after the mode is changed by the user. */</span></span><br><span class="line">      onModeChange?: <span class="function">(<span class="params">mode: Mode</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">      onClassName?: <span class="function">(<span class="params">args: &#123; path: unknown; field: unknown; value: unknown &#125;</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** Provide a version of the Ace editor. Only applicable when mode is code */</span></span><br><span class="line">      ace?: object;</span><br><span class="line">      <span class="comment">/** Provide a instance of ajv,the library used for JSON schema validation. */</span></span><br><span class="line">      ajv?: object;</span><br><span class="line">      <span class="comment">/** Set the Ace editor theme, uses included &#x27;ace/theme/jsoneditor&#x27; by default. */</span></span><br><span class="line">      theme?: string;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Enables history, adds a button Undo and Redo to the menu of the JSONEditor.</span></span><br><span class="line"><span class="comment">       * Only applicable when mode is &#x27;tree&#x27; or &#x27;form&#x27;. Default to false</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      history?: boolean;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Adds navigation bar to the menu</span></span><br><span class="line"><span class="comment">       * the navigation bar visualize the current position on the</span></span><br><span class="line"><span class="comment">       * tree structure as well as allows breadcrumbs navigation. Default to true</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      navigationBar?: boolean;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Adds status bar to the buttom of the editor</span></span><br><span class="line"><span class="comment">       * the status bar shows the cursor position and a count of the selected characters.</span></span><br><span class="line"><span class="comment">       * Only applicable when mode is &#x27;code&#x27; or &#x27;text&#x27;. Default to true</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      statusBar?: boolean;</span><br><span class="line">      <span class="comment">/** Enables a search box in the upper right corner of the JSONEditor. Default to true */</span></span><br><span class="line">      search?: boolean;</span><br><span class="line">      <span class="comment">/** Create a box in the editor menu where the user can switch between the specified modes. */</span></span><br><span class="line">      allowedModes?: <span class="title class_">Mode</span>[];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** Html element, or react element to render */</span></span><br><span class="line">      tag?: string | <span class="title class_">HTMLElement</span>;</span><br><span class="line">      <span class="comment">/** html element custom props */</span></span><br><span class="line">      htmlElementProps?: object;</span><br><span class="line">      <span class="comment">/** callback to get html element reference */</span></span><br><span class="line">      innerRef?: <span class="function">(<span class="params">ref: unknown</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;jsoneditor-react-d-ts&quot;&gt;&lt;a href=&quot;#jsoneditor-react-d-ts&quot; class=&quot;headerlink&quot; title=&quot;jsoneditor-react.d.ts&quot;&gt;&lt;/a&gt;jsoneditor-react.d.ts&lt;/</summary>
      
    
    
    
    <category term="TypeScript" scheme="https://nevvvver.github.io/categories/TypeScript/"/>
    
    
    <category term="javascript" scheme="https://nevvvver.github.io/tags/javascript/"/>
    
    <category term="es6" scheme="https://nevvvver.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>可枚举性(enumerable)</title>
    <link href="https://nevvvver.github.io/2022/03/15/enumerable/"/>
    <id>https://nevvvver.github.io/2022/03/15/enumerable/</id>
    <published>2022-03-14T18:53:58.000Z</published>
    <updated>2022-03-15T16:09:02.657Z</updated>
    
    <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><ul><li><p>在 JavaScript 中，对象的属性可以分为<strong>实例属性</strong>和<strong>原型 (prototype) 属性</strong>。</p><ul><li>实例属性：指的是自身属性。</li><li>原型属性：指的是从原型链上继承的属性。</li><li><code>Object.prototype.hasOwnProperty()</code> 可以判断某一个属性是否是对象的自身属性。</li></ul></li><li><p>对象的每一个属性都有一个<strong>描述对象 (Descriptor)</strong> ,描述对象的 <strong>enumerable</strong> 属性称为“可枚举性”。</p></li><li><p>引入“可枚举性”这个概念的最初目的，就是让某些属性可以规避掉 <code>for...in</code> 操作。</p></li></ul><h3 id="可枚举性的作用"><a href="#可枚举性的作用" class="headerlink" title="可枚举性的作用"></a>可枚举性的作用</h3><p>与可枚举性有关的操作：</p><table><thead><tr><th>函数方法</th><th>描述</th><th align="center">实例属性</th><th align="center">原型属性</th></tr></thead><tbody><tr><td><code>for...in</code></td><td>遍历对象自身和原型上的所有<strong>可枚举</strong>属性</td><td align="center">〇</td><td align="center">〇</td></tr><tr><td><code>Object.keys()</code></td><td>返回对象自身的所有<strong>可枚举</strong>属性的键名</td><td align="center">〇</td><td align="center"></td></tr><tr><td><code>JSON.stringify</code></td><td>只串行化对象自身的所有<strong>可枚举</strong>属性</td><td align="center">〇</td><td align="center"></td></tr><tr><td><code>Object.assign()</code>(ES6)</td><td>只拷贝对象自身的所有<strong>可枚举</strong>属性</td><td align="center">〇</td><td align="center"></td></tr><tr><td><code>Object.getOwnPropertyNames()</code></td><td>返回对象自身的<strong>所有属性</strong>的键名</td><td align="center">〇</td><td align="center"></td></tr></tbody></table><h4 id="code-samples"><a href="#code-samples" class="headerlink" title="code samples"></a>code samples</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Never&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过直接的赋值和属性初始化的属性，可枚举性默认为true</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">School</span> = <span class="string">&#x27;Tust&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Object.defineProperty() 等定义的属性，可枚举性默认为false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;sex&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">    <span class="comment">// enumerable: false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(person).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key) <span class="comment">// name</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> person)&#123;</span><br><span class="line">　　<span class="variable language_">console</span>.<span class="title function_">log</span>(p); <span class="comment">// name, School</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(person).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key)<span class="comment">// name, sex</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="如何判断属性是否可枚举"><a href="#如何判断属性是否可枚举" class="headerlink" title="如何判断属性是否可枚举"></a>如何判断属性是否可枚举</h3><ul><li><code>Object.propertyIsEnumerable()</code> 方法可以判断一个属性是否是对象的<strong>可枚举的自身属性</strong>。（注：如果判断的属性是原型属性，不管它是否可枚举都会返回false）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">person.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&#x27;School&#x27;</span>); <span class="comment">// false</span></span><br><span class="line">person.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&#x27;sex&#x27;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在 JavaScript 中，对象的属性可以分为&lt;strong&gt;实例属性&lt;/strong&gt;和&lt;strong&gt;原型 (pro</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://nevvvver.github.io/categories/JavaScript/"/>
    
    
    <category term="javascript" scheme="https://nevvvver.github.io/tags/javascript/"/>
    
    <category term="es6" scheme="https://nevvvver.github.io/tags/es6/"/>
    
  </entry>
  
</feed>
